<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>  Chapter 18: Loading |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    <header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <p>Translated by Vincent <span class="caps">ISAMBART</span></p>
<h1>Chapter 18: Loading</h1>
<h2>Outline</h2>
<h3>Interface</h3>
<p>At the Ruby level, there are two procedures that can be used for
loading: <code>require</code> and <code>load</code>.</p>
<pre class="emlist">
require 'uri'            # load the uri library
load '/home/foo/.myrc'   # read a resource file
</pre>
<p>They are both normal methods, compiled and evaluated exactly like any
other code. It means loading occurs after compilation gave control to
the evaluation stage.</p>
<p>These two function each have their own use. &#8216;require&#8217; is to load
libraries, and <code>load</code> is to load an arbitrary file. Let&#8217;s see this in
more details.</p>
<h4><code>require</code></h4>
<p><code>require</code> has four features:</p>
<ul>
	<li>the file is searched for in the load path</li>
	<li>it can load extension libraries</li>
	<li>the <code>.rb</code>/<code>.so</code> extension can be omitted</li>
	<li>a given file is never loaded more than once</li>
</ul>
<p>Ruby&#8217;s load path is in the global variable <code>$:</code>, which contains an
array of strings. For example, displaying the content of the <code>$:</code> in
the environment I usually use would show:</p>
<pre class="screen">
% ruby -e 'puts $:'
/usr/lib/ruby/site_ruby/1.7
/usr/lib/ruby/site_ruby/1.7/i686-linux
/usr/lib/ruby/site_ruby
/usr/lib/ruby/1.7
/usr/lib/ruby/1.7/i686-linux
.
</pre>
<p>Calling <code>puts</code> on an array displays one element on each line so it&#8217;s easy
to read.</p>
<p>As I ran <code>configure</code> using <code>--prefix=/usr</code>, the library path is
<code>/usr/lib/ruby</code> and below, but if you compile it normally from the
source code, the libraries will be in <code>/usr/local/lib/ruby</code> and below.
In a Windows environment, there will also be a drive letter.</p>
<p>Then, let&#8217;s try to <code>require</code> the standard library <code>nkf.so</code> from the
load path.</p>
<pre class="emlist">
require 'nkf'
</pre>
<p>If the <code>require</code>d name has no extension, <code>require</code> silently
compensates. First, it tries with <code>.rb</code>, then with <code>.so</code>. On some
platforms it also tries the platform&#8217;s specific extension for
extension libraries, for example <code>.dll</code> in a Windows environment or
<code>.bundle</code> on Mac OS X.</p>
<p>Let&#8217;s do a simulation on my environment. <code>ruby</code> checks the following
paths in sequential order.</p>
<pre class="emlist">
/usr/lib/ruby/site_ruby/1.7/nkf.rb
/usr/lib/ruby/site_ruby/1.7/nkf.so
/usr/lib/ruby/site_ruby/1.7/i686-linux/nkf.rb
/usr/lib/ruby/site_ruby/1.7/i686-linux/nkf.so
/usr/lib/ruby/site_ruby/nkf.rb
/usr/lib/ruby/site_ruby/nkf.so
/usr/lib/ruby/1.7/nkf.rb
/usr/lib/ruby/1.7/nkf.so
/usr/lib/ruby/1.7/i686-linux/nkf.rb
/usr/lib/ruby/1.7/i686-linux/nkf.so    found!
</pre>
<p><code>nkf.so</code> has been found in <code>/usr/lib/ruby/1.7/i686-linux</code>. Once the
file has been found, <code>require</code>&#8217;s last feature (not loading the file
more than once) locks the file. The locks are strings put in the
global variable <code>$"</code>. In our case the string <code>"nkf.so"</code> has been put
there. Even if the extension has been omitted when calling <code>require</code>,
the file name in <code>$"</code> has the extension.</p>
<pre class="emlist">
require 'nkf'   # after loading nkf...
p $"            # ["nkf.so"]  the file is locked

require 'nkf'   # nothing happens if we require it again
p $"            # ["nkf.so"]  the content of the lock array does not change
</pre>
<p>The are two reasons for adding the missing extension. The first one is
not to load it twice if the same file is later <code>require</code>d with its
extension. The second one is to be able to load both <code>nkf.rb</code> and
<code>nkf.so</code>. In fact the extensions are disparate (<code>.so .dll .bundle</code>
etc.) depending on the platform, but at locking time they all become
<code>.so</code>. That&#8217;s why when writing a Ruby program you can ignore the
differences of extensions and consider it&#8217;s always <code>so</code>. So you can
say that <code>ruby</code> is quite <span class="caps">UNIX</span> oriented.</p>
<p>By the way, <code>$"</code> can be freely modified even at the Ruby level so we
cannot say it&#8217;s a strong lock. You can for example load an extension
library multiple times if you clear <code>$"</code>.</p>
<h4><code>load</code></h4>
<p><code>load</code> is a lot easier than <code>require</code>. Like <code>require</code>, it searches the
file in <code>$:</code>. But it can only load Ruby programs. Furthermore, the
extension cannot be omitted: the complete file name must always be
given.</p>
<pre class="emlist">
load 'uri.rb'   # load the URI library that is part of the standard library
</pre>
<p>In this simple example we try to load a library, but the proper way to
use <code>load</code> is for example to load a resource file giving its full
path.</p>
<h3>Flow of the whole process</h3>
<p>If we roughly split it, &#8220;loading a file&#8221; can be split in:</p>
<ul>
	<li>finding the file</li>
	<li>reading the file and mapping it to an internal form</li>
	<li>evaluating it</li>
</ul>
<p>The only difference between <code>require</code> and <code>load</code> is how to find the
file. The rest is the same in both.</p>
<p>We will develop the last evaluation part a little more. Loaded Ruby
programs are basically evaluated at the top-level. It means the
defined constants will be top-level constants and the defined methods
will be function-style methods.</p>
<pre class="emlist">
### mylib.rb
MY_OBJECT = Object.new
def my_p(obj)
  p obj
end

### first.rb
require 'mylib'
my_p MY_OBJECT   # we can use the constants and methods defined in an other file
</pre>
<p>Only the local variable scope of the top-level changes when the file
changes. In other words, local variables cannot be shared between
different files. You can of course share them using for example <code>Proc</code>
but this has nothing to do with the load mechanism.</p>
<p>Some people also misunderstand the loading mechanism. Whatever the
class you are in when you call <code>load</code>, it does not change
anything. Even if, like in the following example, you load a file in
the <code>module</code> statement, it does not serve any purpose, as everything
that is at the top-level of the loaded file is put at the Ruby
top-level.</p>
<pre class="emlist">
require 'mylib'     # whatever the place you require from, be it at the top-level
module SandBox
  require 'mylib'   # or in a module, the result is the same
end
</pre>
<h3>Highlights of this chapter</h3>
<p>Here the mechanism is a lot about details, so it&#8217;s a little difficult
to enumerate it simply. That&#8217;s why we will work a little differently
on it, and we are going to reduce the target to 3 points:</p>
<ul>
	<li>loading serialisation</li>
	<li>the repartition of the functions in the different source files</li>
	<li>how extension libraries are loaded</li>
</ul>
<p>Regarding the first point, you will understand it when you see it.</p>
<p>For the second point, the functions that appear in this chapter come
from 4 different files, <code>eval.c ruby.c file.c dln.c</code>.  We&#8217;ll look at
the reason they are stretched in different places.</p>
<p>The third point is just like its name says. We will see how the
currently popular trend of execution time loading, more commonly
referred to as plug-ins, works. This is the most important part of this
chapter, so I&#8217;d like to use as many pages as possible to talk about it.</p>
<h2>Searching the library</h2>
<h3><code>rb_f_require()</code></h3>
<p>The body of <code>require</code> is <code>rb_f_require</code>. First, we will only look at
the part concerning the file search. Having many different cases is
bothersome so we will limit ourselves to the case when no file
extension is given.</p>
<p>▼ <code>rb_f_require()</code> (simplified version)
<pre class="longlist">
5527  <span class="caps">VALUE</span>
5528  rb_f_require(obj, fname)
5529      <span class="caps">VALUE</span> obj, fname;
5530  {
5531      <span class="caps">VALUE</span> feature, tmp;
5532      char <strong>ext, *ftptr; /</strong> OK <strong>/
5533      int state;
5534      volatile int safe = ruby_safe_level;
5535
5536      SafeStringValue(fname);
5537      ext = strrchr(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr, &#8216;.&#8217;);
5538      if (ext) {
              /</strong> &#8230;if the file extension has been given&#8230; <strong>/
5584      }
5585      tmp = fname;
5586      switch (rb_find_file_ext(&amp;tmp, loadable_ext)) {
5587        case 0:
5588          break;
5589
5590        case 1:
5591          feature = fname = tmp;
5592          goto load_rb;
5593
5594        default:
5595          feature = tmp;
5596          fname = rb_find_file(tmp);
5597          goto load_dyna;
5598      }
5599      if (rb_feature_p(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr, Qfalse))
5600          return Qfalse;
5601      rb_raise(rb_eLoadError, &#8220;No such file to load &#8212; %s&#8221;,
                   <acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5602
5603    load_dyna:
          /</strong> &#8230;load an extension library&#8230; <strong>/
5623      return Qtrue;
5624
5625    load_rb:
          /</strong> &#8230;load a Ruby program&#8230; */
5648      return Qtrue;
5649  }</p>
<p>5491  static const char <strong>const loadable_ext[] = {
5492      &#8220;.rb&#8221;, <span class="caps">DLEXT</span>,    /</strong> <span class="caps">DLEXT</span>=&#8220;.so&#8221;, &#8220;.dll&#8221;, &#8220;.bundle&#8221;&#8230; <strong>/
5493  #ifdef DLEXT2
5494      DLEXT2,          /</strong> DLEXT2=&#8220;.dll&#8221; on Cygwin, MinGW */
5495  #endif
5496      0
5497  };</p>
<p>(eval.c)
</pre></p>
<p>In this function the <code>goto</code> labels <code>load_rb</code> and <code>load_dyna</code> are
actually like subroutines, and the two variables <code>feature</code> and <code>fname</code>
are more or less their parameters. These variables have the following
meaning.</p>
<table>
	<tr>
		<td>variable</td>
		<td>meaning</td>
		<td>example</td>
	</tr>
	<tr>
		<td><code>feature</code></td>
		<td>the library file name that will be put in <code>$"</code></td>
		<td><code>uri.rb</code>、<code>nkf.so</code></td>
	</tr>
	<tr>
		<td><code>fname</code></td>
		<td>the full path to the library</td>
		<td><code>/usr/lib/ruby/1.7/uri.rb</code></td>
	</tr>
</table>
<p>The name <code>feature</code> can be found in the function <code>rb_feature_p()</code>. This
function checks if a file has been locked (we will look at it just
after).</p>
<p>The functions actually searching for the library are <code>rb_find_file()</code>
and <code>rb_find_file_ext()</code>. <code>rb_find_file()</code> searches a file in the load
path <code>$'</code>. <code>rb_find_file_ext()</code> does the same but the difference is
that it takes as a second parameter a list of extensions
(i.e. <code>loadable_ext</code>) and tries them in sequential order.</p>
<p>Below we will first look entirely at the file searching code, then we
will look at the code of the <code>require</code> lock in <code>load_rb</code>.</p>
<h3><code>rb_find_file()</code></h3>
<p>First the file search continues in <code>rb_find_file()</code>. This function
searches the file <code>path</code> in the global load path <code>$'</code>
(<code>rb_load_path</code>). The string contamination check is tiresome so we&#8217;ll
only look at the main part.</p>
<p>▼ <code>rb_find_file()</code> (simplified version)
<pre class="longlist">
2494  <span class="caps">VALUE</span>
2495  rb_find_file(path)
2496      <span class="caps">VALUE</span> path;
2497  {
2498      <span class="caps">VALUE</span> tmp;
2499      char *f = <acronym title="path"><span class="caps">RSTRING</span></acronym>&#8594;ptr;
2500      char *lpath;</p>
<p>2530      if (rb_load_path) {
2531          long i;
2532
2533          Check_Type(rb_load_path, T_ARRAY);
2534          tmp = rb_ary_new();
2535          for (i=0;i&lt;<acronym title="rb_load_path"><span class="caps">RARRAY</span></acronym>&#8594;len;i++) {
2536              <span class="caps">VALUE</span> str = <acronym title="rb_load_path"><span class="caps">RARRAY</span></acronym>&#8594;ptr[i];
2537              SafeStringValue(str);
2538              if (<acronym title="str"><span class="caps">RSTRING</span></acronym>&#8594;len &gt; 0) {
2539                  rb_ary_push(tmp, str);
2540              }
2541          }
2542          tmp = rb_ary_join(tmp, rb_str_new2(PATH_SEP));
2543          if (<acronym title="tmp"><span class="caps">RSTRING</span></acronym>&#8594;len == 0) {
2544              lpath = 0;
2545          }
2546          else {
2547              lpath = <acronym title="tmp"><span class="caps">RSTRING</span></acronym>&#8594;ptr;
2551          }
2552      }</p>
<p>2560      f = dln_find_file(f, lpath);
2561      if (file_load_ok(f)) {
2562          return rb_str_new2(f);
2563      }
2564      return 0;
2565  }</p>
<p>(file.c)
</pre></p>
<p>If we write what happens in Ruby we get the following:</p>
<pre class="emlist">
tmp = []                     # make an array
$:.each do |path|            # repeat on each element of the load path
  tmp.push path if path.length &gt; 0 # check the path and push it
end
lpath = tmp.join(PATH_SEP)   # concatenate all elements in one string separated by PATH_SEP

dln_find_file(f, lpath)      # main processing
</pre>
<p><code>PATH_SEP</code> is the <code>path separator</code>: <code>':'</code> under <span class="caps">UNIX</span>, <code>';'</code> under
Windows. <code>rb_ary_join()</code> creates a string by putting it between the
different elements. In other words, the load path that had become an
array is back to a string with a separator.</p>
<p>Why? It&#8217;s only because <code>dln_find_file()</code> takes the paths as a string
with <code>PATH_SEP</code> as a separator. But why is <code>dln_find_file()</code>
implemented like that? It&#8217;s just because <code>dln.c</code> is not a library for
<code>ruby</code>. Even if it has been written by the same author, it&#8217;s a general
purpose library. That&#8217;s precisely for this reason that when I sorted
the files by category in the Introduction I put this file in the
Utility category. General purpose libraries cannot receive Ruby
objects as parameters or read <code>ruby</code> global variables.</p>
<p><code>dln_find_file()</code> also expands for example <code>~</code> to the home directory,
but in fact this is already done in the omitted part of
<code>rb_find_file()</code>. So in <code>ruby</code>&#8216;s case it&#8217;s not necessary.</p>
<h3>Loading wait</h3>
<p>Here, file search is finished quickly. Then comes is the loading
code. Or more accurately, it is &#8220;up to just before the load&#8221;. The code
of <code>rb_f_require()</code>&#8217;s <code>load_rb</code> has been put below.</p>
<p>▼ <code>rb_f_require():load_rb</code>
<pre class="longlist">
5625    load_rb:
5626      if (rb_feature_p(<acronym title="feature"><span class="caps">RSTRING</span></acronym>&#8594;ptr, Qtrue))
5627          return Qfalse;
5628      ruby_safe_level = 0;
5629      rb_provide_feature(feature);
5630      /* the loading of Ruby programs is serialised <strong>/
5631      if (!loading_tbl) {
5632          loading_tbl = st_init_strtable();
5633      }
5634      /</strong> partial state <strong>/
5635      ftptr = ruby_strdup(<acronym title="feature"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5636      st_insert(loading_tbl, ftptr, curr_thread);
          /</strong> &#8230;load the Ruby program and evaluate it&#8230; <strong>/
5643      st_delete(loading_tbl, &amp;ftptr, 0); /</strong> loading done */
5644      free(ftptr);
5645      ruby_safe_level = safe;</p>
<p>(eval.c)
</pre></p>
<p>Like mentioned above, <code>rb_feature_p()</code> checks if a lock has been put
in <code>$"</code>. And <code>rb_provide_feature()</code> pushes a string in <code>$"</code>, in other
words locks the file.</p>
<p>The problem comes after. Like the comment says &#8220;the loading of Ruby
programs is serialised&#8221;. In other words, a file can only be loaded
from one thread, and if during the loading another thread tries to load the
same file, that thread will wait for the first loading to be finished.
If it were not the case:</p>
<pre class="emlist">
Thread.fork {
    require 'foo'   # At the beginning of require, foo.rb is added to $"
}                   # However the thread changes during the evaluation of foo.rb
require 'foo'   # foo.rb is already in $" so the function returns immediately
# (A) the classes of foo are used...
</pre>
<p>By doing something like this, even though the <code>foo</code> library is not
really loaded, the code at (A) ends up being executed.</p>
<p>The process to enter the waiting state is simple. A <code>st_table</code> is
created in <code>loading_tbl</code>, the association &#8220;<code>feature=&gt;</code>waiting thread&#8221;
is recorded in it. <code>curr_thread</code> is in <code>eval.c</code>&#8217;s functions, its value
is the current running thread.</p>
<p>The mechanism to enter the waiting state is very simple. A <code>st_table</code>
is created in the <code>loading_tbl</code> global variable, and a
&#8220;<code>feature</code>=&gt;<code>loading thread</code>&#8221; association is created. <code>curr_thread</code> is
a variable from <code>eval.c</code>, and its value is the currently running
thread.  That makes an exclusive lock. And in <code>rb_feature_p()</code>, we
wait for the loading thread to end like the following.</p>
<p>▼ <code>rb_feature_p()</code> (second half)
<pre class="longlist">
5477  rb_thread_t th;
5478
5479  while (st_lookup(loading_tbl, f, &amp;th)) {
5480      if (th == curr_thread) {
5481          return Qtrue;
5482      }
5483      CHECK_INTS;
5484      rb_thread_schedule();
5485  }</p>
<p>(eval.c)
</pre></p>
<p>When <code>rb_thread_schedule()</code> is called, the control is transferred to
an other thread, and this function only returns after the control
returned back to the thread where it was called. When the file name
disappears from <code>loading_tbl</code>, the loading is finished so the function
can end. The <code>curr_thread</code> check is not to lock itself (figure 1).</p>
<p class="image">
<p><img src="images/ch_load_loadwait.png" alt="(loadwait)"><br>
Figure 1: Serialisation of loads</p>
</p>
<h2>Loading of Ruby programs</h2>
<h3><code>rb_load()</code></h3>
<p>We will now look at the loading process itself. Let&#8217;s start by the
part inside <code>rb_f_require()</code>&#8217;s <code>load_rb</code> loading Ruby programs.</p>
<p>▼ <code>rb_f_require()-load_rb-</code> loading
<pre class="longlist">
5638      PUSH_TAG(PROT_NONE);
5639      if ((state = EXEC_TAG()) == 0) {
5640          rb_load(fname, 0);
5641      }
5642      POP_TAG();</p>
<p>(eval.c)
</pre></p>
<p>The <code>rb_load()</code> which is called here is actually the &#8220;meat&#8221; of the
Ruby-level <code>load</code>.
ということは探索がもう一回必要になるわけで、同じ作業をもう一回見るなん
てやっていられない。そこでその部分は以下では省略してある。</p>
<p>And since the second argument (<code>wrap</code>) passed to <code>rb_load</code> in the above code is 0, the call is wrapped in 0. (<strong>*</strong> What is this supposed to mean??? That the nesting level is 0?)
また第二引数の<code>wrap</code>も、上記の呼び出しコードで0なので、0で畳み込んである。</p>
<p>▼ <code>rb_load()</code> (simplified edition)
<pre class="longlist">
void
rb_load(fname, /* wrap=0 */)
    <span class="caps">VALUE</span> fname;
{
    int state;
    volatile ID last_func;
    volatile <span class="caps">VALUE</span> wrapper = 0;
    volatile <span class="caps">VALUE</span> self = ruby_top_self;
    <span class="caps">NODE</span> *saved_cref = ruby_cref;</p>
PUSH_VARS();
PUSH_CLASS();
ruby_class = rb_cObject;
ruby_cref = top_cref;           /* (A-1) CREFを変える */
wrapper = ruby_wrapper;
ruby_wrapper = 0;
PUSH_FRAME();
ruby_frame&#8594;last_func = 0;
ruby_frame&#8594;last_class = 0;
ruby_frame&#8594;self = self;        /* (A-2) ruby_frame&#8594;cbaseを変える */
ruby_frame&#8594;cbase = (<span class="caps">VALUE</span>)rb_node_newnode(NODE_CREF,ruby_class,0,0);
PUSH_SCOPE();
/* at the top-level the visibility is private by default */
SCOPE_SET(SCOPE_PRIVATE);
PUSH_TAG(PROT_NONE);
ruby_errinfo = Qnil;  /* make sure it&#8217;s nil */
state = EXEC_TAG();
last_func = ruby_frame&#8594;last_func;
if (state == 0) {
<span class="caps">NODE</span> *node;
/* (B)なぜかevalと同じ扱い */
ruby_in_eval++;
rb_load_file(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
ruby_in_eval&#8212;;
node = ruby_eval_tree;
if (ruby_nerrs == 0) {   /* no parse error occurred */
eval_node(self, node);
}
}
ruby_frame&#8594;last_func = last_func;
POP_TAG();
ruby_cref = saved_cref;
POP_SCOPE();
POP_FRAME();
POP_CLASS();
POP_VARS();
ruby_wrapper = wrapper;
if (ruby_nerrs &gt; 0) {   /* a parse error occurred */
ruby_nerrs = 0;
rb_exc_raise(ruby_errinfo);
}
if (state) jump_tag_but_local_jump(state);
if (!NIL_P(ruby_errinfo))   /* an exception was raised during the loading */
rb_exc_raise(ruby_errinfo);
<p>}
</pre></p>
<p>やっとスタック操作の嵐から抜けられたと思った瞬間また突入するというのも
精神的に苦しいものがあるが、気を取りなおして読んでいこう。</p>
<p>長い関数の常で、コードのほとんどがイディオムで占められている。
<code>PUSH</code>/<code>POP</code>、タグプロテクトと再ジャンプ。その中でも注目したいのは
(A)の<code>CREF</code>関係だ。ロードしたプログラムは常にトップレベル上で
実行されるので、<code>ruby_cref</code>を(プッシュではなく)退避し<code>top_cref</code>に戻す。
<code>ruby_frame-&gt;cbase</code>も新しいものにしている。</p>
<p>それともう一ヶ所、(B)でなぜか<code>ruby_in_eval</code>をオンにしている。そもそも
この変数はいったい何に影響するのか調べてみると、<code>rb_compile_error()</code>とい
う関数だけのようだ。<code>ruby_in_eval</code>が真のときは例外オブジェクトにメッセージを
保存、そうでないときは<code>stderr</code>にメッセージを出力、となっている。つまりコ
マンドのメインプログラムのパースエラーのときはいきなり<code>stderr</code>に出力した
いのだが評価器の中ではそれはまずいので止める、という仕組みらしい。すると
<code>ruby_in_eval</code>のevalはメソッド<code>eval</code>や関数<code>eval()</code>ではなくて一般動詞の
evaluateか、はたまた<code>eval.c</code>のことを指すのかもしれない。</p>
<h3><code>rb_load_file()</code></h3>
<p>ここでソースファイルは突然<code>ruby.c</code>へと移る。と言うよりも実際のところは
こうではないだろうか。即ち、ロード関係のファイルは本来<code>ruby.c</code>に置きたい。
しかし<code>rb_load()</code>では<code>PUSH_TAG()</code>などを使わざるを得ない。だから仕方なく
<code>eval.c</code>に置く。でなければ最初から全部<code>eval.c</code>に置くだろう。</p>
<p>それで、<code>rb_load_file()</code>だ。</p>
<p>▼ <code>rb_load_file()</code>
<pre class="longlist">
 865  void
 866  rb_load_file(fname)
 867      char *fname;
 868  {
 869      load_file(fname, 0);
 870  }</p>
<p>(ruby.c)
</pre></p>
<p>まるごと委譲。<code>load_file()</code>の第二引数<code>script</code>は真偽値で、<code>ruby</code>コマンドの
引数のファイルをロードしているのかどうかを示す。今はそうではなく
ライブラリのロードと考えたいので<code>script=0</code>で疊み込もう。
さらに以下では意味も考え本質的でないものを削ってある。</p>
<p>▼ <code>load_file()</code> (simplified edition)
<pre class="longlist">
static void
load_file(fname, /* script=0 */)
    char *fname;
{
    <span class="caps">VALUE</span> f;
    {
        <span class="caps">FILE</span> *fp = fopen(fname, &#8220;r&#8221;);   (A)
        if (fp == <span class="caps">NULL</span>) {
            rb_load_fail(fname);
        }
        fclose(fp);
    }
    f = rb_file_open(fname, &#8220;r&#8221;);       (B)
    rb_compile_file(fname, f, 1);       &#169;
    rb_io_close(f);
}
</pre></p>
<p>(A) The call to <code>fopen()</code> is to check if the
file can be opened. If there is no problem, it&#8217;s immediately closed.
It may seem a little useless but it&#8217;s an extremely simple and yet
highly portable and reliable way to do it.</p>
<p>(B) The file is opened once again, this time using the Ruby level
library <code>File.open</code>. The file was not opened with <code>File.open</code> from the
beginning so as not to raise any Ruby exception if the file cannot be
opened.  Here if any exception occurred we would like to have a
loading error, but getting the errors related to <code>open</code>, for example
<code>Errno::ENOENT</code>, <code>Errno::EACCESS</code>&#8230;, would be problematic. We are in
<code>ruby.c</code> so we cannot stop a tag jump.</p>
<p>&#169; Using the parser interface <code>rb_compile_file()</code>, the program is
read from an <code>IO</code> object, and compiled in a syntax tree. The syntax
tree is added to <code>ruby_eval_tree</code> so there is no need to get the
result.</p>
<p>That&#8217;s all for the loading code. Finally, the calls were quite deep so
let&#8217;s look at the callgraph of <code>rb_f_require()</code> bellow.</p>
<pre class="emlist">
rb_f_require           ....eval.c
    rb_find_file            ....file.c
        dln_find_file           ....dln.c
            dln_find_file_1
    rb_load
        rb_load_file            ....ruby.c
            load_file
                rb_compile_file     ....parse.y
        eval_node
</pre>
<p>We&#8217;ve seen a lot of callgraphs, they are now common sense.</p>
<h4>The number of <code>open</code> required for loading</h4>
<p>Like we&#8217;ve seen before, there are <code>open</code> used just to check if a file
can be open, but in fact during the loading process other functions
like for example <code>rb_find_file_ext()</code> also do checks using <code>open</code>. How
many times is <code>open()</code> called in the whole process?</p>
<p>If you&#8217;re wondering that, it&#8217;s just a matter of having the right program available to count and see. You can easily find out using a system call tracer. On Linux, the tool to use would be <code>strace</code>; on Solaris, <code>truss</code>; or on <span class="caps">BSD</span>, <code>ktrace</code> or <code>truss</code>.</p>
<p>というように
OSによって名前がてんでバラバラなのだが、Googleで検索すればすぐ見付かる</p>
<p>If you&#8217;re using Windows, probably your <span class="caps">IDE</span> will have a tracer built in. Well, as my main environment is Linux, I looked using <code>strace</code>.</p>
<p>The output is done on <code>stderr</code> so it was redirected using <code>2&gt;&amp;1</code>.</p>
<pre class="screen">
% strace ruby -e 'require "rational"' 2&gt;&amp;1 | grep '^open'
open("/etc/ld.so.preload", O_RDONLY)    = -1 ENOENT
open("/etc/ld.so.cache", O_RDONLY)      = 3
open("/usr/lib/libruby-1.7.so.1.7", O_RDONLY) = 3
open("/lib/libdl.so.2", O_RDONLY)       = 3
open("/lib/libcrypt.so.1", O_RDONLY)    = 3
open("/lib/libc.so.6", O_RDONLY)        = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
open("/usr/lib/ruby/1.7/rational.rb", O_RDONLY|O_LARGEFILE) = 3
</pre>
<p><code>libc.so.6</code>の<code>open</code>まではダイナミックリンクの実装で使っている<code>open</code>なので
残りの<code>open</code>は計四回。つまり三回は無駄になっているようだ。</p>
<h2>Loading of extension libraries</h2>
<h3><code>rb_f_require()</code>-<code>load_dyna</code></h3>
<p>This time we will see the loading of extension libraries. We will
start with <code>rb_f_require()</code>&#8217;s <code>load_dyna</code>. However, we do not need the
part about locking anymore so it was removed.</p>
<p>▼ <code>rb_f_require()</code>-<code>load_dyna</code>
<pre class="longlist">
5607  {
5608      int volatile old_vmode = scope_vmode;
5609
5610      PUSH_TAG(PROT_NONE);
5611      if ((state = EXEC_TAG()) == 0) {
5612          void *handle;
5613
5614          SCOPE_SET(SCOPE_PUBLIC);
5615          handle = dln_load(<acronym title="fname"><span class="caps">RSTRING</span></acronym>&#8594;ptr);
5616          rb_ary_push(ruby_dln_librefs, <acronym title="(long"><span class="caps">LONG2NUM</span></acronym>handle));
5617      }
5618      POP_TAG();
5619      SCOPE_SET(old_vmode);
5620  }
5621  if (state) JUMP_TAG(state);</p>
<p>(eval.c)
</pre></p>
<p>By now, there is very little here which is novel. タグはイディオム通りの使いかた
しかしていないし、可視性スコープの退避・復帰も見慣れた手法だ。
All that remains is <code>dln_load()</code>. What on earth is that for? For the answer, continue to the next section.</p>
<h3>リンクについて復習</h3>
<p><code>dln_load()</code>は拡張ライブラリをロードしているわけだが、拡張ライブラリを
ロードするとはどういうことなのだろうか。それを話すにはまず話を思い切り
物理世界方向に巻き戻し、リンクのことから始めなければならない。</p>
<p>Cのプログラムをコンパイルしたことはもちろんあると思う。筆者は
Linuxで<code>gcc</code>を使っているので、次のようにすれば動くプログラムが
作成できる。</p>
<pre class="screen">
% gcc hello.c
</pre>
<p>ファイル名からするときっとこれはHello, World!プログラムなんだろう。
<code>gcc</code>はUNIXではデフォルトで<code>a.out</code>というファイルにプログラムを
出力するので続いて次のように実行できる。</p>
<pre class="screen">
% ./a.out
Hello, World!
</pre>
<p>It prints out just as expected.</p>
<p>By the way, what is <code>gcc</code> actually doing here? Usually we just say is &#8220;compiles&#8221;, but actually it&#8230;</p>
<ol>
	<li>Preprocesses (<code>cpp</code>)</li>
	<li>Compiles C into assembly (<code>cc</code>)</li>
	<li>Assembles the assembly language into machine code (<code>as</code>)</li>
	<li>Links (<code>ld</code>)</li>
</ol>
<p>という四つの段階を通っている。このうちプリプロセス・コンパイル・アセン
ブルまではいろいろなところで説明を見掛けるのだが、なぜかリンクの段階だ
けは明文化されずに終わることが多いようだ。学校の歴史の授業では絶対に
「現代」まで行き着かない、というのと同じようなものだろうか。そこで本書
ではその断絶を埋めるべく、まずリンクとは何なのか簡単にまとめておくこと
にする。</p>
<p>アセンブルまでの段階が完了したプログラムはなんらかの形式の
「オブジェクトファイル」
になっている。そのような形式でメジャーなものには以下のよう
なものがある。</p>
<ul>
	<li><span class="caps">ELF</span>, Executable and Linking Format(新しめのUNIX)</li>
	<li><code>a.out</code>, assembler output(比較的古いUNIX)</li>
	<li><span class="caps">COFF</span>, Common Object File Format(Win32)</li>
</ul>
<p>念のため言っておくが、オブジェクトファイル形式の<code>a.out</code>と<code>cc</code>の
デフォルト出力ファイル名の<code>a.out</code>は全然別物である。例えば今時のLinuxで
普通に作ればELF形式のファイル<code>a.out</code>ができる。</p>
<p>それで、このオブジェクトファイル形式がどう違うのか、という話はこのさい
どうでもいい。今認識しなければならないのは、これらのオブジェクトファイ
ルはどれも「名前の集合」と考えられるということだ。例えばこのファイルに
存在する関数名や変数名など。</p>
<p>またオブジェクトファイルに含まれる名前の集合には二種類がある。即ち</p>
<ul>
	<li>必要な名前の集合(例えば内部から呼んでいる外部関数。例:<code>printf</code>)</li>
	<li>提供する名前の集合(例えば内部で定義している関数。例:<code>hello</code>)</li>
</ul>
<p>である。そしてリンクとは、複数のオブジェクトファイルを集めてきたときに
全てのオブジェクトファイルの「必要な名前の集合」が「提供する名前の集合」
の中に含まれることを確認し、かつ互いに結び付けることだ。つまり全ての
「必要な名前」から線をひっぱって、どこかのオブジェクトファイルが「提供
する名前」につなげられるようにしなければいけない(図2)。
このことを用語を使って
言えば、未定義シンボルを解決する(resolving undefined symbol)、となる。</p>
<p class="image">
<p><img src="images/ch_load_link.png" alt="(link)"><br>
Figure 2: オブジェクトファイルとリンク</p>
</p>
<p>論理的にはそういうことだが、現実にはそれだけではプログラムは走らないわ
けだ。少なくともCのプログラムは走らない。名前をアドレス(数)に変換し
てもらわなければ動けないからだ。</p>
<p>そこで論理的な結合の次には物理的な結合が必要になる。オブジェクトファイ
ルを現実のメモリ空間にマップし、全ての名前を数で置き換えないといけない。
具体的に言えば関数呼び出し時のジャンプ先アドレスを調節したりする。</p>
<p>そしてこの二つの結合をいつやるかによってリンクは二種類に分かれる。即ち
スタティックリンクとダイナミックリンクである。スタティックリンクはコン
パイル時に全段階を終了してしまう。一方ダイナミックリンクは結合のうちい
くらかをプログラムの実行時まで遅らせる。そしてプログラムの実行時になっ
て初めてリンクが完了する。</p>
<p>もっともここで説明したのは非常に単純な理想的モデルであって現実をかなり
歪曲している面がある。論理結合と物理結合はそんなにキッパリ分かれるもの
ではないし、「オブジェクトファイルは名前の集合」というのもナイーブに過
ぎる。しかしなにしろこのあたりはプラットフォームによってあまりに動作が
違いすぎるので、真面目に話していたら本がもう一冊書けてしまう。
現実レベルの知識を得るためにはさらに
『エキスパートCプログラミング』\footnote{『エキスパートCプログラミング』Peter van der Linden著、梅原系訳、アスキー出版局、1996}
『Linkers&amp;Loaders』@footnote{『Linkers&amp;Loaders』John R.Levine著、榊原一矢監訳 ポジティブエッジ訳、オーム社、2001}
あたりも読んでおくとよい。</p>
<h3>真にダイナミックなリンク</h3>
<p>And finally we get into our main topic. The &#8220;dynamic&#8221; in &#8220;dynamic linking&#8221; naturally means it &#8220;occurs at execution time&#8221;, but what people usually refer to as &#8220;dynamic linking&#8221; is pretty much decided already at compile time. For example, the names of the needed functions, and which library they can be found in, are already known. For instance, if you need <code>cos()</code>, you know it&#8217;s in <code>libm</code>, so you use <code>gcc -lm</code>. If you didn&#8217;t specify the correct library at compile time, you&#8217;d get a link error.</p>
<p>But extension libraries are different. Neither the names of the needed functions, or the name of the library which defines them are known at compile time. 
文字列をプログラムの実
行中に組み立ててロード・リンクしなければいけないのである。つまり先程の
言葉で言う「論理結合」すらも全て実行時に行わなければならない。そのため
には普通に言うところのダイナミックリンクとはまた少し違う仕組みが必要に
なる。</p>
<p>この操作、つまり実行時に全てを決めるリンク、のことを普通は
「動的ロード(dynamic load)」と呼ぶ。本書の用語遣いからいくと
「ダイナミックロード」と片仮名にひらくべきなのだろうが、
ダイナミックリンクと
ダイナミックロードだと紛らわしいのであえて漢字で「動的ロード」とする。</p>
<h3>動的ロードAPI</h3>
<p>概念の説明は以上だ。あとはその動的ロードをどうやればいいかである。とは
言っても難しいことはなくて、普通はシステムに専用APIが用意されているの
でこちらは単にそれを呼べばいい。</p>
<p>例えばUNIXならわりと広範囲にあるのが<code>dlopen</code>というAPIである。ただし
「UNIXならある」とまでは言えない。例えばちょっと前のHP-UXには全く違う
インターフェイスがあるしMac OS XだとNeXT風のAPIを使う。また同じ
<code>dlopen</code>でもBSD系だと<code>libc</code>にあるのにLinuxだと<code>libdl</code>として外付けになっ
ている、などなど、壮絶なまでに移植性がない。いちおうUNIX系と並び称され
ていてもこれだけ違うわけだから、他のOSになれば全然違うのもあたりまえで
ある。同じAPIが使われていることはまずありえない。</p>
<p>そこで<code>ruby</code>はどうしているかというと、その全然違うインターフェイスを吸収
するために<code>dln.c</code>というファイルを用意している。<code>dln</code>はdynamic linkの略だろ
う。<code>dln_load()</code>はその<code>dln.c</code>の関数の一つなのである。</p>
<p>そんなふうに全くバラバラの動的ロードAPIだが、せめてもの救
いはAPIの使用パターンが全く同じだということだ。どのプラットフォームだ
ろうと</p>
<ol>
	<li>ライブラリをプロセスのアドレス空間にマップする</li>
	<li>ライブラリに含まれる関数へのポインタを取る</li>
	<li>ライブラリをアンマップ</li>
</ol>
<p>という三段階で構成されている。例えば<code>dlopen</code>系APIならば</p>
<ol>
	<li><code>dlopen</code></li>
	<li><code>dlsym</code></li>
	<li><code>dlclose</code></li>
</ol>
<p>が対応する。Win32 APIならば</p>
<ol>
	<li><code>LoadLibrary</code>(または<code>LoadLibraryEx</code>)</li>
	<li><code>GetProcAddress</code></li>
	<li><code>FreeLibrary</code></li>
</ol>
<p>が対応する。</p>
<p>最後に、このAPI群を使って<code>dln_load()</code>が何をするかを話そう。これが実は、
<code>Init_xxxx()</code>の呼び出しなのだ。ここに至ってついに<code>ruby</code>起動から終了までの全
過程が欠落なく描けるようになる。即ち、<code>ruby</code>は起動すると評価器を初期化し
なんらかの方法で受け取ったメインプログラムの評価を開始する。その途中で
<code>require</code>か<code>load</code>が起こるとライブラリをロードし制御を移す。制御を移す、と
は、Rubyライブラリならばパースして評価することであり、拡張ライブラリな
らばロード・リンクして<code>Init_xxxx()</code>を呼ぶことである。</p>
<h3><code>dln_load()</code></h3>
<p>ようやく<code>dln_load()</code>の中身にたどりつけた。<code>dln_load()</code>も長い関数だが、これ
また理由があって構造は単純である。まず概形を見てほしい。</p>
<p>▼ <code>dln_load()</code>(概形)
<pre class="longlist">
void*
dln_load(file)
    const char <strong>file;
{
#if defined _WIN32 &amp;&amp; !defined <i><span class="caps">CYGWIN</span></i>
    Win32 APIでロード
#else
    プラットフォーム独立の初期化
#ifdef 各プラットフォーム
    ……プラットフォームごとのルーチン……
#endif
#endif
#if !defined(<em><span class="caps">AIX</span>) &amp;&amp; !defined(NeXT)
  failed:
    rb</em>loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
#endif
    return 0;                   /</strong> dummy return */
}
</pre></p>
<p>このようにメインとなる部分がプラットフォームごとに完璧に分離しているため、
考えるときは一つ一つのプラットフォームのことだけを考えていればいい。
サポートされているAPIは以下の通りだ。</p>
<ul>
	<li><code>dlopen</code>(多くのUNIX)</li>
	<li><code>LoadLibrary</code>(Win32)</li>
	<li><code>shl_load</code>(少し古いHP-UX)</li>
	<li><code>a.out</code>(かなり古いUNIX)</li>
	<li><code>rld_load</code>(<code>NeXT4</code>未満)</li>
	<li><code>dyld</code>(<code>NeXT</code>またはMac OS X)</li>
	<li><code>get_image_symbol</code>(BeOS)</li>
	<li><code>GetDiskFragment</code>(Mac OS 9以前)</li>
	<li><code>load</code>(少し古いAIX)</li>
</ul>
<h3><code>dln_load()</code>-<code>dlopen()</code></h3>
<p>First, let&#8217;s start with the <span class="caps">API</span> code for the <code>dlopen</code> series.</p>
<p>▼ <code>dln_load()</code>-<code>dlopen()</code>
<pre class="longlist">
1254  void*
1255  dln_load(file)
1256      const char <strong>file;
1257  {
1259      const char *error = 0;
1260  #define DLN_ERROR() (error = dln_strerror(),\
                           strcpy(ALLOCA_N(char, strlen(error) + 1), error))
1298      char *buf;
1299      /</strong> Init_xxxxという文字列をbufに書き込む(領域はalloca割り当て) */
1300      init_funcname(&amp;buf, file);</p>
<p>1304      {
1305          void <strong>handle;
1306          void (</strong>init_fct)();
1307
1308  #ifndef RTLD_LAZY
1309  # define RTLD_LAZY 1
1310  #endif
1311  #ifndef RTLD_GLOBAL
1312  # define RTLD_GLOBAL 0
1313  #endif
1314
1315          /* (A)ライブラリをロード <strong>/
1316          if ((handle = (void</strong>)dlopen(file, RTLD_LAZY | RTLD_GLOBAL))
                                                                 == <span class="caps">NULL</span>) {
1317              error = dln_strerror();
1318              goto failed;
1319          }
1320
              /* (B)Init_xxxx()へのポインタを取る <strong>/
1321          init_fct = (void(</strong>)())dlsym(handle, buf);
1322          if (init_fct == <span class="caps">NULL</span>) {
1323              error = DLN_ERROR();
1324              dlclose(handle);
1325              goto failed;
1326          }
1327          /* &#169;Init_xxxx()を呼ぶ <strong>/
1328          (</strong>init_fct)();
1329
1330          return handle;
1331      }</p>
<p>1576    failed:
1577      rb_loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
1580  }</p>
<p>(dln.c)
</pre></p>
<p>(A)<code>dlopen()</code>の引数の<code>RTLD_LAZY</code>は「実際に関数を要求したときに
未解決シンボルを解決する」ことを示す。返り値はライブラリを識別する
ための印(ハンドル)で、<code>dl*()</code>には常にこれを渡さないといけない。</p>
<p>(B)<code>dlsym()</code>はハンドルの示すライブラリから関数ポインタを取る。返り値が
<code>NULL</code>なら失敗だ。ここで<code>Init_xxxx()</code>へのポインタを取り、呼ぶ。</p>
<p><code>dlclose()</code>の呼び出しはない。<code>Init_xxxx()</code>の中でロードした
ライブラリの関数ポインタを
返したりしているはずだが、<code>dlclose()</code>するとライブラリ全体が使えなくなって
しまうのでまずいのだ。つまりプロセスが終了するまで<code>dlclose()</code>は呼べない。</p>
<h3><code>dln_load()</code>-Win32</h3>
<p>Win32では<code>LoadLibrary()</code>と<code>GetProcAddress()</code>を使う。
MSDNにも載っているごく一般的なWin32 APIである。</p>
<p>▼ <code>dln_load()</code>-Win32
<pre class="longlist">
1254  void*
1255  dln_load(file)
1256      const char *file;
1257  {</p>
<p>1264      <span class="caps">HINSTANCE</span> handle;
1265      char winfile[<span class="caps">MAXPATHLEN</span>];
1266      void (<strong>init_fct)();
1267      char *buf;
1268
1269      if (strlen(file) &gt;= <span class="caps">MAXPATHLEN</span>) rb_loaderror(&#8220;filename too long&#8221;);
1270
1271      /</strong> &quot;Init_xxxx&quot;という文字列をbufに書き込む(領域はalloca割り当て) <strong>/
1272      init_funcname(&amp;buf, file);
1273
1274      strcpy(winfile, file);
1275
1276      /</strong> ライブラリをロード <strong>/
1277      if ((handle = LoadLibrary(winfile)) == <span class="caps">NULL</span>) {
1278          error = dln_strerror();
1279          goto failed;
1280      }
1281
1282      if ((init_fct = (void(</strong>)())GetProcAddress(handle, buf)) == <span class="caps">NULL</span>) {
1283          rb_loaderror(&#8220;%s &#8211; %s\n%s&#8221;, dln_strerror(), buf, file);
1284      }
1285
1286      /* Init_xxxx()を呼ぶ <strong>/
1287      (</strong>init_fct)();
1288      return handle;</p>
<p>1576    failed:
1577      rb_loaderror(&#8220;%s &#8211; %s&#8221;, error, file);
1580  }</p>
<p>(dln.c)
</pre></p>
<p><code>LoadLibrary()</code>して<code>GetProcAddress()</code>。ここまでパターンが同じだと
言うこともないので、終わってしまうことにしよう。</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
