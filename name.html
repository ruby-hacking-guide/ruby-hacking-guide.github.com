<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>  Chapter 3: Names and name tables |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    <header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <p>Translated by Clifford Escobar <span class="caps">CAOILE</span></p>
<h1>Chapter 3: Names and Name Table</h1>
<h2><code>st_table</code></h2>
<p><code>st_table</code> has already appeared several times as a method table and an instance
table. In this chapter let&#8217;s look at the structure of the <code>st_table</code> in detail.</p>
<h3>Summary</h3>
<p>I previously mentioned that the <code>st_table</code> is a hash table. What is a hash
table? It is a data structure that records one-to-one relations, for example, a
variable name and its value, or a function name and its body, etc.</p>
<p>However, data structures other than hash tables can, of course, record
one-to-one relations. For example, a list of the following structs will suffice
for this purpose.</p>
<pre class="emlist">
struct entry {
    ID key;
    VALUE val;
    struct entry *next;  /* point to the next entry */
};
</pre>
<p>However, this method is slow. If the list contains a thousand items, in the
worst case, it is necessary to traverse a thousand links. In other words, the
search time increases in proportion to the number of elements.  This is bad.
Since ancient times, various speed improvement methods have been conceived. The
hash table is one of those improved methods. In other words, the point is not
that the hash table is necessary but that it can be made faster.</p>
<p>Now then, let us examine the <code>st_table</code>. As it turns out, this library is not
created by Matsumoto, rather:</p>
<p>▼ <code>st.c</code> credits</p>
<pre class="longlist">
   1  /* This is a public domain general purpose hash table package
         written by Peter Moore @ UCB. */

(st.c)
</pre>
<p>as shown above.</p>
<p>By the way, when I searched Google and found another version, it mentioned
that <code>st_table</code> is a contraction of &#8220;STring <span class="caps">TABLE</span>&#8221;. However, I find it
contradictory that it has both &#8220;general purpose&#8221; and &#8220;string&#8221; aspects.</p>
<h4>What is a hash table?</h4>
<p>A hash table can be thought as the following: Let us think of an array with
<code>n</code> items. For example, let us make <code>n</code>=64 (figure 1).</p>
<p class="image">
<p><img src="images/ch_name_array.png" alt="(array)"><br>
Figure 1: Array</p>
</p>
<p>Then let us specify a function <code>f</code> that takes a key and produces an integer <code>i</code>
from 0 to <code>n</code>-1 (0-63). We call this <code>f</code> a hash function. <code>f</code> when given the
same key always produces the same <code>i</code>. For example, if we can assume that the
key is limited to positive integers, when the key is divided by 64, the
remainder should always fall between 0 and 63. Therefore, this calculating
expression has a possibility of being the function <code>f</code>.</p>
<p>When recording relationships, given a key, function <code>f</code> generates <code>i</code>, and
places the value into index <code>i</code> of the array we have prepared. Index access
into an array is very fast. The key concern is changing a key into an integer.</p>
<p class="image">
<p><img src="images/ch_name_aset.png" alt="(aset)"><br>
Figure 2: Array assignment</p>
</p>
<p>However, in the real world it isn&#8217;t that easy. There is a critical problem with
this idea. Because <code>n</code> is only 64, if there are more than 64 relationships to
be recorded, it is certain that there will be the same index for two different
keys.  It is also possible that with fewer than 64, the same thing can occur.
For example, given the previous hash function &#8220;key % 64&#8221;, keys 65 and 129 will
both have a hash value of 1. This is called a hash value collision. There are
many ways to resolve such a collision.</p>
<p>One solution is to insert into the next element when a collision occurs.
This is called open addressing. (Figure 3).</p>
<p class="image">
<p><img src="images/ch_name_nexti.png" alt="(nexti)"><br>
Figure 3: Open addressing</p>
</p>
<p>Other than using the array like this, there are other possible approaches, like using
a pointer to a respective linked list in each element of the array. Then when a
collision occurs, grow the linked list. This is called chaining. (Figure
4) <code>st_table</code> uses this chaining method.</p>
<p class="image">
<p><img src="images/ch_name_chain.png" alt="(chain)"><br>
Figure 4: Chaining</p>
</p>
<p>However, if it can be determined a priori what set of keys will be used,
it is possible to imagine a hash function that will never create
collisions. This type of function is called a &#8220;perfect hash function&#8221;.
Actually, there are tools which create a perfect hash function given a set
of arbitrary strings. <span class="caps">GNU</span> gperf is one of those. <code>ruby</code>&#8216;s parser
implementation uses <span class="caps">GNU</span> gperf but&#8230; this is not the time to discuss it.
We&#8217;ll discuss this in the second part of the book.</p>
<h3>Data Structure</h3>
<p>Let us start looking at the source code. As written in the introductory
chapter, if there is data and code, it is better to read the data first.
The following is the data type of <code>st_table</code>.</p>
<p>▼ <code>st_table</code></p>
<pre class="longlist">
   9  typedef struct st_table st_table;

  16  struct st_table {
  17      struct st_hash_type *type;
  18      int num_bins;                   /* slot count */
  19      int num_entries;                /* total number of entries */
  20      struct st_table_entry **bins;   /* slot */
  21  };

(st.h)
</pre>
<p>▼ <code>struct st_table_entry</code></p>
<pre class="longlist">
  16  struct st_table_entry {
  17      unsigned int hash;
  18      char *key;
  19      char *record;
  20      st_table_entry *next;
  21  };

(st.c)
</pre>
<p><code>st_table</code> is the main table structure. <code>st_table_entry</code> is a holder that
stores one value. <code>st_table_entry</code> contains a member called <code>next</code> which of
course is used to make <code>st_table_entry</code> into a linked list. This is the chain
 part of the chaining method. The <code>st_hash_type</code> data type is used, but I will
 explain this later. First let me explain the other parts so you can compare
and understand the roles.</p>
<p class="image">
<p><img src="images/ch_name_sttable.png" alt="(sttable)"><br>
Figure 5: <code>st_table</code> data structure</p>
</p>
<p>So, let us comment on <code>st_hash_type</code>.</p>
<p>▼ <code>struct st_hash_type</code></p>
<pre class="longlist">
  11  struct st_hash_type {
  12      int (*compare)();   /* comparison function */
  13      int (*hash)();      /* hash function */
  14  };

(st.h)
</pre>
<p>This is still Chapter 3 so let us examine it attentively.</p>
<pre class="emlist">
int (*compare)()
</pre>
<p>This part shows, of course, the member <code>compare</code> which has a data type of
&#8220;a pointer to a function that returns an <code>int</code>&#8221;. <code>hash</code> is also of the same type.
This variable is substituted in the following way:</p>
<pre class="emlist">
int
great_function(int n)
{
    /* ToDo: Do something great! */
    return n;
}

{
    int (*f)();
    f = great_function;
</pre>
<p>And it is called like this:</p>
<pre class="emlist">
    (*f)(7);
}
</pre>
<p>Here let us return to the <code>st_hash_type</code> commentary. Of the two members
<code>hash</code> and <code>compare</code>, <code>hash</code> is the hash function <code>f</code> explained previously.</p>
<p>On the other hand, <code>compare</code> is a function that evaluates if the key is actually the
same or not. With the chaining method, in the spot with the same hash value
<code>n</code>, multiple elements can be inserted. To know exactly which element is
being searched for, this time it is necessary to use a comparison function
that we can absolutely trust. <code>compare</code> will be that function.</p>
<p>This <code>st_hash_type</code> is a good generalized technique. The hash table itself
cannot determine what the stored keys&#8217; data type will be. For example, in
<code>ruby</code>, <code>st_table</code>&#8217;s keys are <code>ID</code> or <code>char*</code> or <code>VALUE</code>, but to write the
same kind of hash for each (data type) is foolish. Usually, the things
that change with the different key data types are things like the hash
function. For things like memory allocation and collision detection,
typically most of the code is the same. Only the parts where the
implementation changes with a differing data type will be bundled up into a
function, and a pointer to that function will be used. In this fashion, the
majority of the code that makes up the hash table implementation can
use it.</p>
<p>In object-oriented languages, in the first place, you can attach a procedure
to an object and pass it (around), so this mechanism is not necessary.
Perhaps it more correct to say that this mechanism is built-in as a
language&#8217;s feature.</p>
<h3><code>st_hash_type</code> example</h3>
<p>The usage of a data structure like <code>st_hash_type</code> is good as an
abstraction. On the other hand, what kind of code it actually passes
through may be difficult to understand. If we do not examine what sort of
function is used for <code>hash</code> or <code>compare</code>, we will not grasp the reality.
To understand this, it is probably sufficient to look at <code>st_init_numtable()</code>
introduced in the previous chapter. This function creates a table for
integer data type keys.</p>
<p>▼ <code>st_init_numtable()</code></p>
<pre class="longlist">
 182  st_table*
 183  st_init_numtable()
 184  {
 185      return st_init_table(&amp;type_numhash);
 186  }

(st.c)
</pre>
<p><code>st_init_table()</code> is the function that allocates the table memory and so
on. <code>type_numhash</code> is an <code>st_hash_type</code> (it is the member named &#8220;type&#8221; of <code>st_table</code>).
Regarding this <code>type_numhash</code>:</p>
<p>▼ <code>type_numhash</code></p>
<pre class="longlist">
  37  static struct st_hash_type type_numhash = {
  38      numcmp,
  39      numhash,
  40  };

 552  static int
 553  numcmp(x, y)
 554      long x, y;
 555  {
 556      return x != y;
 557  }

 559  static int
 560  numhash(n)
 561      long n;
 562  {
 563      return n;
 564  }

(st.c)
</pre>
<p>Very simple. The table that the <code>ruby</code> interpreter uses is by and large
this <code>type_numhash</code>.</p>
<h3><code>st_lookup()</code></h3>
<p>Now then, let us look at the function that uses this data structure. First,
it&#8217;s a good idea to look at the function that does the searching. Shown below is the
function that searches the hash table, <code>st_lookup()</code>.</p>
<p>▼ <code>st_lookup()</code></p>
<pre class="longlist">
 247  int
 248  st_lookup(table, key, value)
 249      st_table *table;
 250      register char *key;
 251      char **value;
 252  {
 253      unsigned int hash_val, bin_pos;
 254      register st_table_entry *ptr;
 255
 256      hash_val = do_hash(key, table);
 257      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 258
 259      if (ptr == 0) {
 260          return 0;
 261      }
 262      else {
 263          if (value != 0)  *value = ptr-&gt;record;
 264          return 1;
 265      }
 266  }

(st.c)
</pre>
<p>The important parts are pretty much in <code>do_hash()</code> and <code>FIND_ENTRY()</code>. Let us
look at them in order.</p>
<p>▼ <code>do_hash()</code></p>
<pre class="longlist">
  68  #define do_hash(key,table) (unsigned int)(*(table)-&gt;type-&gt;hash)((key))

(st.c)
</pre>
<p>Just in case, let us write down the macro body that is difficult to understand:</p>
<pre class="emlist">
(table)-&gt;type-&gt;hash
</pre>
<p>is a function pointer where the <code>key</code> is passed as a parameter. This is the
syntax for calling the function. <code>*</code> is not applied to <code>table</code>. In other words,
this macro is a hash value generator for a <code>key</code>, using the prepared hash
function <code>type-&gt;hash</code> for each data type.</p>
<p>Next, let us examine <code>FIND_ENTRY()</code>.</p>
<p>▼ <code>FIND_ENTRY()</code></p>
<pre class="longlist">
 235  #define FIND_ENTRY(table, ptr, hash_val, bin_pos) do {\
 236      bin_pos = hash_val%(table)-&gt;num_bins;\
 237      ptr = (table)-&gt;bins[bin_pos];\
 238      if (PTR_NOT_EQUAL(table, ptr, hash_val, key)) {\
 239          COLLISION;\
 240          while (PTR_NOT_EQUAL(table, ptr-&gt;next, hash_val, key)) {\
 241              ptr = ptr-&gt;next;\
 242          }\
 243          ptr = ptr-&gt;next;\
 244      }\
 245  } while (0)

 227  #define PTR_NOT_EQUAL(table, ptr, hash_val, key) ((ptr) != 0 &amp;&amp; \
          (ptr-&gt;hash != (hash_val) || !EQUAL((table), (key), (ptr)-&gt;key)))

  66  #define EQUAL(table,x,y) \
          ((x)==(y) || (*table-&gt;type-&gt;compare)((x),(y)) == 0)

(st.c)
</pre>
<p><code>COLLISION</code> is a debug macro so we will (should) ignore it.</p>
<p>The parameters of <code>FIND_ENTRY()</code>, starting from the left are:</p>
<ol>
	<li><code>st_table</code></li>
	<li>the found entry will be pointed to by this parameter</li>
	<li>hash value</li>
	<li>temporary variable</li>
</ol>
<p>And, the second parameter will point to the found <code>st_table_entry*</code>.</p>
<p>At the outermost level, a <code>do</code> .. <code>while(0)</code> is used to safely wrap up a
multiple expression macro. This is <code>ruby</code>&#8216;s, or rather, C language&#8217;s preprocessor
idiom. In the case of <code>if(1)</code>, there may be a danger of adding an <code>else</code> part.
In the case of <code>while(1)</code>, it becomes necessary to add a <code>break</code> at the very
end.</p>
<p>Also, there is no semicolon added after the <code>while(0)</code>.</p>
<pre class="emlist">
FIND_ENTRY();
</pre>
<p>This is so that the semicolon that is normally written at the end of an
expression will not go to waste.</p>
<h3><code>st_add_direct()</code></h3>
<p>Continuing on, let us examine <code>st_add_direct()</code> which is a function that adds a
new relationship to the hash table. This function does not check if the key is
already registered. It always adds a new entry. This is the meaning of <code>direct</code>
in the function name.</p>
<p>▼ <code>st_add_direct()</code></p>
<pre class="longlist">
 308  void
 309  st_add_direct(table, key, value)
 310      st_table *table;
 311      char *key;
 312      char *value;
 313  {
 314      unsigned int hash_val, bin_pos;
 315
 316      hash_val = do_hash(key, table);
 317      bin_pos = hash_val % table-&gt;num_bins;
 318      ADD_DIRECT(table, key, value, hash_val, bin_pos);
 319  }

(st.c)
</pre>
<p>Just as before, the <code>do_hash()</code> macro that obtains a value is called here.
After that, the next calculation is the same as at the start of
<code>FIND_ENTRY()</code>, which is to exchange the hash value for a real index.</p>
<p>Then the insertion operation seems to be implemented by <code>ADD_DIRECT()</code>.
Since the name is all uppercase, we can anticipate that is a macro.</p>
<p>▼ <code>ADD_DIRECT()</code></p>
<pre class="longlist">
 268  #define ADD_DIRECT(table, key, value, hash_val, bin_pos) \
 269  do {                                                     \
 270      st_table_entry *entry;                               \
 271      if (table-&gt;num_entries / (table-&gt;num_bins)           \
                              &gt; ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table-&gt;num_bins;            \
 274      }                                                    \
 275                                                           \
          /* (A) */                                            \
 276      entry = alloc(st_table_entry);                       \
 277                                                           \
 278      entry-&gt;hash = hash_val;                              \
 279      entry-&gt;key = key;                                    \
 280      entry-&gt;record = value;                               \
          /* (B) */                                            \
 281      entry-&gt;next = table-&gt;bins[bin_pos];                  \
 282      table-&gt;bins[bin_pos] = entry;                        \
 283      table-&gt;num_entries++;                                \
 284  } while (0)

(st.c)
</pre>
<p>The first <code>if</code> is an exception case so I will explain it afterwards.</p>
<p>(A) Allocate and initialize a <code>st_table_entry</code>.</p>
<p>(B) Insert the <code>entry</code> into the start of the list.
This is the idiom for handling the list. In other words,</p>
<pre class="emlist">
entry-&gt;next = list_beg;
list_beg = entry;
</pre>
<p>makes it possible to insert an entry to the front of the list. This is similar
to &#8220;cons-ing&#8221; in the Lisp language. Check for yourself that even if <code>list_beg</code>
is <span class="caps">NULL</span>, this code holds true.</p>
<p>Now, let me explain the code I left aside.</p>
<p>▼ <code>ADD_DIRECT()</code>-<code>rehash</code></p>
<pre class="longlist">
 271      if (table-&gt;num_entries / (table-&gt;num_bins)           \
                              &gt; ST_DEFAULT_MAX_DENSITY) {      \
 272          rehash(table);                                   \
 273          bin_pos = hash_val % table-&gt;num_bins;            \
 274      }                                                    \

(st.c)
</pre>
<p><code>DENSITY</code> is &#8220;concentration&#8221;. In other words, this conditional checks if the
hash table is &#8220;crowded&#8221; or not. In the <code>st_table</code>, as the number of values that
use the same <code>bin_pos</code> increases, the longer the link list becomes. In other
words, search becomes slower. That is why for a given <code>bin</code> count, when the average elements
per bin become too many, <code>bin</code> is increased and the crowding is reduced.</p>
<p>The current <code>ST_DEFAULT_MAX_DENSITY</code> is</p>
<p>▼ <code>ST_DEFAULT_MAX_DENSITY</code></p>
<pre class="longlist">
  23  #define ST_DEFAULT_MAX_DENSITY 5

(st.c)
</pre>
<p>Because of this setting, if in all <code>bin_pos</code> there are 5 <code>st_table_entries</code>,
then the size will be increased.</p>
<h3><code>st_insert()</code></h3>
<p><code>st_insert()</code> is nothing more than a combination of <code>st_add_direct()</code> and
<code>st_lookup()</code>, so if you understand those two, this will be easy.</p>
<p>▼ <code>st_insert()</code></p>
<pre class="longlist">
 286  int
 287  st_insert(table, key, value)
 288      register st_table *table;
 289      register char *key;
 290      char *value;
 291  {
 292      unsigned int hash_val, bin_pos;
 293      register st_table_entry *ptr;
 294
 295      hash_val = do_hash(key, table);
 296      FIND_ENTRY(table, ptr, hash_val, bin_pos);
 297
 298      if (ptr == 0) {
 299          ADD_DIRECT(table, key, value, hash_val, bin_pos);
 300          return 0;
 301      }
 302      else {
 303          ptr-&gt;record = value;
 304          return 1;
 305      }
 306  }

(st.c)
</pre>
<p>It checks if the element is already registered in the table. Only when it is
not registered will it be added. If there is a insertion, return 0. If there is
no insertion, return a 1.</p>
<h2><code>ID</code> and Symbols</h2>
<p>I&#8217;ve already discussed what an <code>ID</code> is. It is a correspondence between an
arbitrary string of characters and a value. It is used to declare various
names. The actual data type is <code>unsigned int</code>.</p>
<h3>From <code>char*</code> to <code>ID</code></h3>
<p>The conversion from string to <code>ID</code> is executed by <code>rb_intern()</code>. This function
is rather long, so let&#8217;s omit the middle.</p>
<p>▼ <code>rb_intern()</code> (simplified)</p>
<pre class="longlist">
5451  static st_table *sym_tbl;       /*  char* to ID   */
5452  static st_table *sym_rev_tbl;   /*  ID to char*   */

5469  ID
5470  rb_intern(name)
5471      const char *name;
5472  {
5473      const char *m = name;
5474      ID id;
5475      int last;
5476
          /* If for a name, there is a corresponding ID that is already
          registered, then return that ID */
5477      if (st_lookup(sym_tbl, name, &amp;id))
5478          return id;

          /* omitted ... create a new ID */

          /* register the name and ID relation */
5538    id_regist:
5539      name = strdup(name);
5540      st_add_direct(sym_tbl, name, id);
5541      st_add_direct(sym_rev_tbl, id, name);
5542      return id;
5543  }

(parse.y)
</pre>
<p>The string and <code>ID</code> correspondence relationship can be accomplished by using the
<code>st_table</code>. There probably isn&#8217;t any especially difficult part here.</p>
<p>What is the omitted section doing? It is treating global variable names and
instance variables names as special and flagging them. This is because in the
parser, it is necessary to know the variable&#8217;s classification from the <code>ID</code>.
However, the fundamental part of <code>ID</code> is unrelated to this, so I won&#8217;t explain
it here.</p>
<h3>From <code>ID</code> to <code>char*</code></h3>
<p>The reverse of <code>rb_intern()</code> is <code>rb_id2name()</code>, which takes an <code>ID</code> and
generates a <code>char*</code>. You probably know this, but the 2 in <code>id2name</code> is &#8220;to&#8221;.
&#8220;To&#8221; and &#8220;two&#8221; have the same pronounciation, so &#8220;2&#8221; is used for &#8220;to&#8221;. This
syntax is often seen.</p>
<p>This function also sets the <code>ID</code> classification flags so it is long. Let me
simplify it.</p>
<p>▼ <code>rb_id2name()</code> (simplified)</p>
<pre class="longlist">
char *
rb_id2name(id)
    ID id;
{
    char *name;

    if (st_lookup(sym_rev_tbl, id, &amp;name))
        return name;
    return 0;
}
</pre>
<p>Maybe it seems that it is a little over-simplified, but in reality if we remove
the details it really becomes this simple.</p>
<p>The point I want to emphasize is that the found <code>name</code> is not copied. The
<code>ruby</code> <span class="caps">API</span> does not require (or rather, it forbids) the <code>free()</code>-ing of the
return value. Also, when parameters are passed, it always
copies them. In other words, the creation and release is
completed by one side, either by the user or by <code>ruby</code>.</p>
<p>So then, when creation and release cannot be accomplished (when passed it is
not returned) on a value, then a Ruby object is used. I have not yet discussed
it, but a Ruby object is automatically released when it is no longer needed,
even if we are not taking care of the object.</p>
<h3>Converting <code>VALUE</code> and <code>ID</code></h3>
<p><code>ID</code> is shown as an instance of the <code>Symbol</code> class at the Ruby level.
And it can be obtained like so: <code>"string".intern</code>. The implementation of
<code>String#intern</code> is <code>rb_str_intern()</code>.</p>
<p>▼ <code>rb_str_intern()</code></p>
<pre class="longlist">
2996  static VALUE
2997  rb_str_intern(str)
2998      VALUE str;
2999  {
3000      ID id;
3001
3002      if (!RSTRING(str)-&gt;ptr || RSTRING(str)-&gt;len == 0) {
3003          rb_raise(rb_eArgError, "interning empty string");
3004      }
3005      if (strlen(RSTRING(str)-&gt;ptr) != RSTRING(str)-&gt;len)
3006          rb_raise(rb_eArgError, "string contains `\\0'");
3007      id = rb_intern(RSTRING(str)-&gt;ptr);
3008      return ID2SYM(id);
3009  }

(string.c)
</pre>
<p>This function is quite reasonable as a <code>ruby</code> class library code example.
Please pay attention to the part where <code>RSTRING()</code> is used and casted, and
where the data structure&#8217;s member is accessed.</p>
<p>Let&#8217;s read the code. First, <code>rb_raise()</code> is merely error handling so we ignore
it for now. The <code>rb_intern()</code> we previously examined is here, and also ID2SYM
is here. <code>ID2SYM()</code> is a macro that converts <code>ID</code> to <code>Symbol</code>.</p>
<p>And the reverse operation is accomplished using <code>Symbol#to_s</code> and such.
The implementation is in <code>sym_to_s</code>.</p>
<p>▼ <code>sym_to_s()</code></p>
<pre class="longlist">
 522  static VALUE
 523  sym_to_s(sym)
 524      VALUE sym;
 525  {
 526      return rb_str_new2(rb_id2name(SYM2ID(sym)));
 527  }

(object.c)
</pre>
<p><code>SYM2ID()</code> is the macro that converts <code>Symbol</code> (<code>VALUE</code>) to an <code>ID</code>.</p>
<p>It looks like the function is not doing anything unreasonable. However, it
is probably necessary to pay attention to the area around the memory handling.
<code>rb_id2name()</code> returns a <code>char*</code> that must not be <code>free()</code>. <code>rb_str_new2()</code>
copies the parameter&#8217;s <code>char*</code> and uses the copy (and does not change the
parameter). In this way the policy is consistent, which allows the line to be
written just by chaining the functions.</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
