<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>  Ruby Language Details |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    <header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <h1 id="chapter">Chapter 8 : Ruby Language Details</h1>
<p>I&#8217;ll talk about the details of Ruby&#8217;s syntax and evaluation,
which haven&#8217;t been covered yet. I didn&#8217;t intend a complete exposition,
so I left out everything which doesn&#8217;t come up in this book.
That&#8217;s why you won&#8217;t be able to write Ruby programs just by
reading this. A complete exposition can be found in the
\footnote{Ruby reference manual: <code>archives/ruby-refm.tar.gz</code> in the attached CD-ROM}</p>
<p>Readers who know Ruby can skip over this chapter.</p>
<h2>Literals</h2>
<p>The expressiveness of Ruby&#8217;s literals is extremely high.
What distinguishes Ruby as a scripting language
is firstly the existence of
the toplevel, secondly it&#8217;s the expressiveness of its literals in my
opinion. Thirdly it might be the richness of its standard library.</p>
<p>The literals have already as elements enormous power, but even more
when combined. Especially that one can create complex literals from
hash and array literals is a great advantage of Ruby. One can simply
write down a hash of arrays of regular expressions for instance.</p>
<p>Let&#8217;s look at the valid expressions one by one.</p>
<h3>Strings</h3>
<p>Strings and regular expressions can&#8217;t be missing in a scripting language.
There is a great variety of string literals.</p>
<h4>Single Quoted Strings</h4>
<pre class="emlist">
'string'              # 「string」
'\\begin{document}'   # 「\begin{document}」
'\n'                  # 「\n」backslash and an n, no newline
'\1'                  # 「\1」backslash and 1
'\''                  # 「'」
</pre>
<p>This is the simplest form. In C everything enclosed in single quotes becomes a
string, it&#8217;s the same in Ruby. Let&#8217;s call this a <code>'</code>-string. The backslash escape
is in effect only for <code>\</code> itself and <code>'</code>. If one puts a backslash
in front of another character the backslash remains as for example
in the fourth example.</p>
<p>And Ruby&#8217;s strings aren&#8217;t divided by newline characters.
If we write a string over several lines the newlines are contained
in the string.</p>
<pre class="emlist">
'multi
    line
        string'
</pre>
<p>And if the <code>-K</code> option is given to the <code>ruby</code> command multibyte strings
will be accepted. At present the three encodings <span class="caps">EUC</span>-JP (<code>-Ke</code>),
Shift <span class="caps">JIS</span> (<code>-Ks</code>), and UTF8 (<code>-Ku</code>) can be specified. (Translator&#8217;s note:
<code>-K</code> option was removed in Ruby 1.9)</p>
<pre class="emlist">
'「漢字が通る」と「マルチバイト文字が通る」はちょっと違う'
# 'There's a little difference between "Kanji are accepted" and "Multibyte characters are accepted".'
</pre>
<h4>Double Quoted Strings</h4>
<pre class="emlist">
"string"              # 「string」
"\n"                  # newline
"\x0f"               # a byte given in hexadecimal form
"page#{n}.html"       # embedding a command
</pre>
<p>With double quotes we can use command expansion and backslash notation.
The backslash notation is classical, it was already supported in C,
<code>\n</code> is a newline, <code>\b</code> is a backspace, this kind of notation.
In Ruby also <code>Ctrl-C</code> and <span class="caps">ESC</span> can be expressed, that&#8217;s convenient.
It&#8217;s probably of no use to list the whole notation here.</p>
<p>On the other hand, expression expansion is even more fantastic.
We can write an arbitrary Ruby expression inside <code>#{ }</code> and it
will be evaluated at runtime and embedded into the string. There
are no limitations like only one variable or only one method.
This is not a mere literal anymore but a whole expression representing
a string.</p>
<pre class="emlist">
"embedded #{lvar} expression"
"embedded #{@ivar} expression"
"embedded #{1 + 1} expression"
"embedded #{method_call(arg)} expression"
"embedded #{"string in string"} expression"
</pre>
<h4>Strings with <code>%</code></h4>
<pre class="emlist">
%q(string)            # same as 'string'
%Q(string)            # same as "string"
%(string)             # same as %Q(string) or "string"
</pre>
<p>If a lot of separator characters appear in a string, escaping all of them
becomes a burden. In that case the separator characters can be
changed. The string which contains the one character <code>"</code> can be
written with a <code>%</code> string as follows:</p>
<pre class="emlist">
"&lt;a href=\"http://i.loveruby.net#{path}\"&gt;"
%Q(")
</pre>
<p>The expression isn&#8217;t shorter, but nicer to look at.
When we have to escape more often, it even becomes more concise.</p>
<p>Here we have used parentheses as delimiters, but something else is fine,
too. Like brackets or braces or <code>#</code>. Almost every symbol is fine, even
<code>%</code>.</p>
<pre class="emlist">
%q#this is string#
%q[this is string]
%q%this is string%
</pre>
<h4>Here Documents</h4>
<p>Here documents are a syntactical device where one or more lines can
form a string. A normal string starts right after the delimiter <code>"</code>
and takes everything until the ending <code>"</code>. Here documents start
at the line after a <code>&lt;&lt;EOS</code> and end at the line before the ending <code>EOS</code>.</p>
<pre class="emlist">

&lt;&lt;EOS
All lines between the starting and
the ending line are in this
here document
EOS
</pre>
<p>Here we used <code>EOS</code> as identifier but any word is fine.
Precisely speaking all the character matching <code>[a-zA-Z_0-9]</code> can be used.</p>
<p>The characteristic of a here document is that every line between
the start symbol and the ending symbol will form a string. The line
which contains the start symbol delimits the string.
That&#8217;s why the position of the start symbol is not important.
It can even be in the middle of an expression:</p>
<pre class="emlist">
printf(&lt;&lt;EOS, count_n(str))
count=%d
EOS
</pre>
<p>In this case the string <code>"count=%d\n"</code> goes in the place of <code>&lt;&lt;EOS</code>.
So it&#8217;s the same as the following.</p>
<pre class="emlist">
printf("count=%d\n", count_n(str))
</pre>
<p>The start symbol can be somewhere in the line, but there are strict
rules for the ending symbol: It must be at the beginning of the line
and there must not be another letter in that line. However
if we write the start symbol with a minus like this <code>&lt;&lt;-EOS</code> we
can indent the line with the end symbol.</p>
<pre class="emlist">
     &lt;&lt;-EOS
It would be convenient if one could indent the content
of a here document. But that's not possible.
If you want that, the best way is to write
a method which delete the indent. But beware
of tabs.
     EOS
</pre>
<p>Furthermore, the start symbol can be enclosed in single or double quotes.
Then the properties of the whole here document change.
When we change <code>&lt;&lt;EOS</code> to <code>&lt;&lt;"EOS"</code> we can use command expression
imbedding and backslash notation.</p>
<pre class="emlist">
    &lt;&lt;"EOS"
One day is #{24 * 60 * 60} seconds.
Incredible.
EOS
</pre>
<p>But <code>&lt;&lt;'EOS'</code> is not the same as a single quoted string. It starts
the complete literal mode. Everything even backslashes go
into the string as they are typed. This is useful for a string which
contains many backslashes.</p>
<p>In the second part we also explain how a here document is passed.
But I&#8217;d like you to guess it before.
(Translators Note: In Ruby 1.8 and 1.9 expression expansion and
backslash notation can be used in a normal here document.
There does not seem to be a difference anymore to a double quote enclosed
here document.)</p>
<h3>Characters</h3>
<p>Ruby strings are byte strings, there are no character objects.
Instead there are the following expressions which return the
integers which correspond a certain character in <span class="caps">ASCII</span> code.</p>
<pre class="emlist">
?a                    # the integer which corresponds to 「a」
?.                    # the integer which corresponds to 「.」
?\n                   # LF
?\C-a                 # Ctrl-a
</pre>
<p>(Translator&#8217;s note: Strings in Ruby 1.9 are not byte strings anymore,
they have an attached encoding. <code>?a</code> returns the string <code>"a"</code> in Ruby1.9)</p>
<h3>Regular Expressions</h3>
<pre class="emlist">
/regexp/
/^Content-Length:/i
/正規表現/
/\/\*.*?\*\//m        # An expression which matches C comments
/reg#{1 + 1}exp/      # the same as /reg2exp/
</pre>
<p>What is contained between slashes is a regular expression.
Regular expressions are a language to designate string patterns.
For example</p>
<pre class="emlist">
/abc/
</pre>
<p>This regular expression matches a string where there&#8217;s an <code>a</code> followed
by a <code>b</code> followed by a <code>c</code>. It matches &#8220;abc&#8221; or &#8220;fffffffabc&#8221; or
&#8220;abcxxxxx&#8221;.</p>
<p>One can designate more special patterns.</p>
<pre class="emlist">
/^From:/
</pre>
<p>This matches a string where there&#8217;s a <code>From</code> followed by a <code>:</code> at
the beginning. There are several more expressions of this kind,
such that one can create quite complex patterns.</p>
<p>The uses are infinite:
Changing the matched part to another string, deleting the matched part,
determining if there&#8217;s one match and and and&#8230;</p>
<p>A more concrete use case would be extracting the <code>From:</code> header
from a mail. Then changing the <code>\n</code> to an <code>\r</code> and
checking if the rest looks like a mail address.</p>
<p>The regular expressions form an independent language, it has
it&#8217;s own parser and evaluator within ruby. It can be found in <code>regex.c</code>
in the Ruby source. In effect from a grammar view point they are
treated the same as strings. Escapes, backslash notation and command
embedding can be used almost the same as in strings.</p>
<p>Of course regular expressions and strings are treated the same
in the Ruby syntax only. Regular expressions themselves are a language
of their own with own rules which have to be obeyed. This is a subject
of a whole other book. We won&#8217;t go deeper into that here.
Refer for instance to Jeffrey Friedl, Regular expressions.</p>
<h4>Regular Expressions with <code>%</code></h4>
<p>Also as with strings, regular expressions also have a syntax for changing
delimiters. In this case it is <code>%r</code>. Here just some examples.</p>
<pre class="emlist">
%r(regexp)
%r[/\*.*?\*/]            # matches a C comment
%r("(?:[^"\\]+|\\.)*")   # matches a string in C
%r{reg#{1 + 1}exp}       # imbedding a Ruby expression
</pre>
<h3>Arrays</h3>
<p>An array literal is contained in brackets <code>[]</code>, elements are separated
by commas.</p>
<pre class="emlist">
[1, 2, 3]
['This', 'is', 'an', 'array', 'of', 'string']

[/regexp/, {'hash'=&gt;3}, 4, 'string', ?\C-a]

lvar = $gvar = @ivar = @@cvar = nil
[lvar, $gvar, @ivar, @@cvar]
[Object.new(), Object.new(), Object.new()]
</pre>
<p>Ruby&#8217;s arrays  are a list of arbitrary objects. From a syntactical
standpoint it&#8217;s characteristic is, that
the elements can be arbitrary expressions. As mentioned earlier,
an array of hashes of regular expressions can easily be made.
Not just literals but also variables or method calls can also be
put together.</p>
<p>And as with the other literals note that this is really an &#8220;expression
which generates an array object&#8221;</p>
<pre class="emlist">
i = 0
while i &lt; 5
  p([1,2,3].id)    # Each time another object id is shown.
  i += 1
end
</pre>
<h4>Word Arrays</h4>
<p>When writing scripts one uses arrays of strings a lot, hence
there is a special notation only for arrays of strings.
That is <code>%w</code>. With an example it&#8217;s immediately obvious.</p>
<pre class="emlist">
%w( alpha beta gamma delta )   # ['alpha','beta','gamma','delta']
%w( 月 火 水 木 金 土 日 )
%w( Jan Feb Mar Apr May Jun
    Jul Aug Sep Oct Nov Dec )
</pre>
<p>There&#8217;s also <code>%W</code> where command embedding can be used.
It&#8217;s a relatively recent implementation.</p>
<pre class="emlist">
n = 5
%w( list0 list#{n} )   # ['list0', 'list#{n}']
%W( list0 list#{n} )   # ['list0', 'list5']
</pre>
<p>The author hasn&#8217;t come up with a good use yet.</p>
<h3>Hashes</h3>
<p>Hash tables are data structure which store a one-to-one relation between
arbitrary objects. The following expressions generate a table.</p>
<pre class="emlist">
{ 'key' =&gt; 'value', 'key2' =&gt; 'value2' }
{ 3 =&gt; 0, 'string' =&gt; 5, ['array'] =&gt; 9 }
{ Object.new() =&gt; 3, Object.new() =&gt; 'string' }

# Of course we can put it in several lines.
{ 0 =&gt; 0,
  1 =&gt; 3,
  2 =&gt; 6 }
</pre>
<p>We explained hashes in detail in the third chapter &#8220;Names and
Nametables&#8221;. They are fast lookup tables which allocate memory slots depending
on the hash values. In Ruby grammar,
both keys and values can be arbitrary expressions.</p>
<p>Furthermore inside the argument of a method call the <code>{...}</code> can be omitted.</p>
<pre class="emlist">
  some_method(arg, key =&gt; value, key2 =&gt; value2)
# some_method(arg, {key =&gt; value, key2 =&gt; value2}) # same as above
</pre>
<p>With this we can imitate named arguments.</p>
<pre class="emlist">
button.set_geometry('x' =&gt; 80, 'y' =&gt; '240')
</pre>
<p>Of course in this case <code>set_geometry</code> must accept a hash as input.
Real keyword arguments will be transformed into parameter variables, though.
With a passed hash it is not quite the real thing.</p>
<h3>Ranges</h3>
<p>Range literals are oddballs which don&#8217;t appear in most other languages.
Here are some expressions which generate Range objects.</p>
<pre class="emlist">
0..5          # from 0 to 5 containing 5
0...5         # from 0 to 5 not containing 5
1+2 .. 9+0    # from 3 to 9 containing 9
'a'..'z'      # strings from 'a' to 'z' containing 'z'
</pre>
<p>If there are two dots the last element is included. If there
are three dots it is not included. Not only integers but also floats
and strings can be made into ranges, even arbitrary objects can
be used in ranges. Syntactically arbitrary expressions can be
used as delimiters of a range object. If the returned object cannot
be made into a range there will be a runtime error.</p>
<p>Besides, the precedence of <code>..</code> and <code>...</code> is quite low. Here&#8217;s a surprising
interpretation.</p>
<pre class="emlist">
1..5.to_a()   # 1..(5.to_a())
</pre>
<p>I thinks the Ruby grammar is really intuitive,
but I do not like this.</p>
<h3>Symbols</h3>
<p>In the first part we talked about symbols at length.
They are something which corresponds one-to-one to strings.
In Ruby symbols are expressed with a <code>:</code> in front.</p>
<pre class="emlist">
:identifier
:abcde
</pre>
<p>These are pretty standard examples. But all symbol and method
names become symbols with a <code>:</code> in front. Like this:</p>
<pre class="emlist">
:$gvar
:@ivar
:@@cvar
:CONST
</pre>
<p>We haven&#8217;t shown any method names so far. Of course <code>[]</code> or <code>attr=</code>
can be used as symbols too.</p>
<pre class="emlist">
:[]
:attr=
</pre>
<p>When one uses these symbols as values in an array, it&#8217;ll look quite
complicated.</p>
<h3>Numerical Values</h3>
<p>This is the least interesting. It might be added that</p>
<pre class="emlist">
1_000_000
</pre>
<p>becomes one million and that underscores can be used inside a number.
But that isn&#8217;t particularly interesting. This is it about numerical
values in this book. We&#8217;ll completely forget them from here on.</p>
<h2>Methods</h2>
<p>Let&#8217;s talk about the definition and calling of methods.</p>
<h3>Definition and Calls</h3>
<pre class="emlist">
def some_method( arg )
  ....
end

class C
  def some_method( arg )
    ....
  end
end
</pre>
<p>Methods are defined with <code>def</code>. If they are defined at toplevel
they become function style methods, inside a class they become
methods of this class. To call a method which was defined in a class,
one usually has to create an instance with <code>new</code> as shown below.</p>
<pre class="emlist">
C.new().some_method(0)
</pre>
<h3>The Return Value of Methods</h3>
<p>The return value of a method is the value of a <code>return</code> statement
if it runs across one.
If there is none it&#8217;s the value of the last statement.</p>
<pre class="emlist">
def one()     # 1 is returned
  return 1
  999
end

def two()     # 2 is returned
  999
  2
end

def three()   # 3 is returned
  if true then
    3
  else
    999
  end
end
</pre>
<p>If the method body is empty <code>nil</code> is returned
and an expression without a value cannot put at the end.
Hence every method has a return value.</p>
<h3>Optional Arguments</h3>
<p>Optional arguments can also be defined. If the number of arguments
doesn&#8217;t suffice the parameters are automatically assigned to a
default value.</p>
<pre class="emlist">
def some_method( arg = 9 )  # default value is 9
  p arg
end

some_method(0)    # 0 is shown.
some_method()     # The default value 9 is shown.
</pre>
<p>There can also be several optional arguments.
But in that case they must all come at the end. It is not
possible to make an argument in the middle optional.
It would be unclear how this should be made sense of.</p>
<pre class="emlist">
def right_decl( arg1, arg2, darg1 = nil, darg2 = nil )
  ....
end

# This is not possible
def wrong_decl( arg, default = nil, arg2 )  # A middle argument cannot be optional
  ....
end
</pre>
<h3>Omitting argument parantheses</h3>
<p>The parentheses from a method call can be omitted.</p>
<pre class="emlist">
puts 'Hello, World!'   # puts("Hello, World")
obj = Object.new       # obj = Object.new()
</pre>
<p>In Python leaving out parentheses gets the method object, but
there is no such thing in Ruby.</p>
<p>We can also omit parentheses within the arguments itself.</p>
<pre class="emlist">
  puts(File.basename fname)
# puts(File.basename(fname)) same as the above
</pre>
<p>If we like we can even leave out more</p>
<pre class="emlist">
  puts File.basename fname
# puts(File.basename(fname))  same as the above
</pre>
<p>In Ruby 2.0 such an expression will probably not pass anymore.</p>
<p>Actually let&#8217;s also leave out the parentheses in the definition</p>
<pre class="emlist">
def some_method param1, param2, param3
end

def other_method    # without arguments we see this a lot
end
</pre>
<p>Parentheses are often left out in method calls, but leaving out
parentheses in the definition is not very popular.
Only if there are no arguments the parentheses are frequently omitted.</p>
<h3>Arguments and Lists</h3>
<p>Arguments form a list of objects. If we want to use the elements of a list as arguments we can do this as follows:</p>
<pre class="emlist">
def delegate(a, b, c)
  p(a, b, c)
end

list = [1, 2, 3]
delegate(*list)   # identical to delegate(1, 2, 3)
</pre>
<p>In this way we can distribute an array into arguments.
We call this device a <code>*</code>argument. Here we used a local variable
for demonstration, but of course there is no limitation.
We can also directly put a literal or a method call instead.</p>
<pre class="emlist">
m(*[1,2,3])    # We could have written the expanded form in the first place...
m(*mcall())
</pre>
<p>The <code>*</code> argument can be used together with ordinary arguments,
but the <code>*</code> argument must come last.</p>
<p>In the definition on the other hand we can handle the arguments in
bulk when we put a <code>*</code> in front of the parameter variable.</p>
<pre class="emlist">
def some_method( *args )
  p args
end

some_method()          # prints []
some_method(0)         # prints [0]
some_method(0, 1)      # prints [0,1]
</pre>
<p>The surplus arguments are gathered in an array. Only one <code>*</code>parameter
can be declared. It must also come after the default arguments.</p>
<pre class="emlist">
def some_method0( arg, *rest )
end
def some_method1( arg, darg = nil, *rest )
end
</pre>
<p>If we combine list expansion and bulk reception together, the arguments
of one method can be passed as a whole to another method. This might
be the most practical use of the <code>*</code>parameter.</p>
<pre class="emlist">
# a method which passes its arguments to other_method
def delegate(*args)
  other_method(*args)
end

def other_method(a, b, c)
  return a + b + c
end

delegate(0, 1, 2)      # same as other_method(0, 1, 2)
delegate(10, 20, 30)   # same as other_method(10, 20, 30)
</pre>
<h3>Various Method Call Expressions</h3>
<p>There is only one mechanism for &#8216;method call&#8217;, but there still
can be several representations of the same mechanism. This is
colloquially called syntactic sugar.</p>
<p>In Ruby there is a ton of it,
and they are really attractive for a person who has a fetish for parsers.
For instance the examples below are all method calls.</p>
<pre class="emlist">
1 + 2                   # 1.+(2)
a == b                  # a.==(b)
~/regexp/               # /regexp/.~
obj.attr = val          # obj.attr=(val)
obj[i]                  # obj.[](i)
obj[k] = v              # obj.[]=(k,v)
&lt;code&gt;cvs diff abstract.rd&lt;/code&gt;  # Kernel.`('cvs diff abstract.rd')
</pre>
<p>It&#8217;s hard to believe until you get used to it, but <code>attr=</code>, <code>[]=</code>, <code>\</code>`
are all names of methods. They can appear as names in a method definition
and can also be used as symbols.</p>
<pre class="emlist">
class C
  def []( index )
  end
  def +( another )
  end
end
p(:attr=)
p(:[]=)
p(:`)
</pre>
<p>There are people who don&#8217;t like sweets and there are people who
hate syntactic sugar. Maybe because one cannot tell by the looks
that it&#8217;s really the same thing. It feels like a deception.
(Why&#8217;s everyone so serious?)</p>
<p>Let&#8217;s see some more details.</p>
<h4>Symbol Appendices</h4>
<pre class="emlist">
obj.name?
obj.name!
</pre>
<p>First a small thing. It&#8217;s just appending a <code>?</code> or a <code>!</code>. Call and Definition
do not differ, so it&#8217;s not too painful. There are convention for what
to use these method names, but there is no enforcement on language level.
It&#8217;s just a convention.
These method names are probably an influence from Lisp which has a great variety
of function names.</p>
<h4>Binary Operators</h4>
<pre class="emlist">
1 + 2    # 1.+(2)
</pre>
<p>Binary Operators will be converted to a method call to the object on the
left hand side. Here the method <code>+</code> from the object <code>1</code> is called.
As listed below there are many of them. There are the general operators
<code>+</code> and <code>-</code>, also the equivalence operator <code>==</code> and the spaceship operator
`&lt;=&gt;&#8217; as in Perl, all sorts. They are listed in order of their precedence.</p>
<pre class="emlist">
**
* / %
+ -
&lt;&lt; &gt;&gt;
&amp;
| ^
&gt; &gt;= &lt; &lt;=
&lt;=&gt; == === =~
</pre>
<p>The symbols <code>&amp;</code> and <code>|</code> are methods, but the double symbols <code>&amp;&amp;</code> and <code>||</code>
are built-in operators. Remember how it is in C.</p>
<h4>Unary Operators</h4>
<pre class="emlist">
+2
-1.0
~/regexp/
</pre>
<p>These are the unary operators. There are only three of them: <code>+ - ~</code>.
<code>+</code> and <code>-</code> work as one would imagine ( in the default setting).
The operator <code>~</code> matches a string or a regular expression
with the variable <code>$_</code>. With an integer it stands for bit conversion.</p>
<p>To distinguish the unary <code>+</code> from the binary <code>+</code> the method names
for the unary operators are <code>+@</code> and <code>-@</code> respectively.
Of course they can be called by just writing <code>+n</code> or <code>-n</code>.</p>
<p>((errata: + or &#8211; as the prefix of a numeric literal is actually scanned as a
part of the literal. This is a kind of optimizations.))</p>
<h4>Attribute Assignment</h4>
<pre class="emlist">
obj.attr = val   # obj.attr=(val)
</pre>
<p>This is an attribute assignment statement. The above will be translated
into the method call <code>attr=</code>. When using this together with method calls whose
parentheses are omitted, we can write code which looks like attribute access.</p>
<pre class="emlist">
class C
  def i() @i end          # We can write the definition in one line
  def i=(n) @i = n end
end

c = C.new
c.i = 99
p c.i    # prints 99
</pre>
<p>However both are method calls.
They are similar to get/set property in Delphi or slot accessors in <span class="caps">CLOS</span>.</p>
<p>Besides, we cannot define a attribute assignment which takes an argument like
<code>obj.attr(arg)=</code>.</p>
<h4>Index Notation</h4>
<pre class="emlist">
obj[i]    # obj.[](i)
</pre>
<p>The above will be translated into a method call for <code>[]</code>.
Array and hash access are also implemented with this device.</p>
<pre class="emlist">
obj[i] = val   # obj.[]=(i, val)
</pre>
<p>When assigning to an index the <code>[]=</code> method is used.</p>
<h3><code>super</code></h3>
<p>Often we don&#8217;t want to replace a method, but we want to add a little
bit to the behaviour of an already existing method. Here it becomes
necessary to not just overwrite the method in the superclass but
to also call the method in the superclass.
That&#8217;s what Ruby&#8217;s <code>super</code> is for.</p>
<pre class="emlist">
class A
  def test
    puts 'in A'
  end
end
class B &lt; A
  def test
    super   # launches A#test
  end
end
</pre>
<p>Ruby&#8217;s `super differs from the one in Java. This one here
calls the method with the same name in the superclass.
In other words <code>super</code> is a reserved word.</p>
<p>When using super be careful about the difference between the difference
of the zero arguments <code>super</code> and the omitted arguments `super.
The super with omitted arguments passes all the parameter variables.</p>
<pre class="emlist">
class A
  def test( *args )
    p args
  end
end

class B &lt; A
  def test( a, b, c )
    # super with no arguments
    super()    # shows []

    # super with omitted arguments. Same result as super(a, b, c)
    super      # shows [1, 2, 3]
  end
end

B.new.test(1,2,3)
</pre>
<h4>Visibility</h4>
<p>Depending on the location ( the object <code>self</code>) a method can or
cannot be called. This function was usually called visibility.
In Ruby there are three kinds of methods.</p>
<ul>
	<li><code>public</code></li>
	<li><code>private</code></li>
	<li><code>protected</code></li>
</ul>
<p><code>public</code> methods can be called from anywhere in any form.
<code>private</code> methods can syntactically only be called without a receiver.
In effect they can only be called by instances of the class
in which they were defined and in instances of its subclass.
<code>protected</code> methods can only be called by instances of the defining class
and its subclasses.
It differs from <code>private</code> that methods can still be called from other
instances of the same class.</p>
<p>The terms are the same as in C++ but the meaning is slightly different.
Be careful.</p>
<p>Usually we control visibility as shown below.</p>
<pre class="emlist">
class C
  public
  def a1() end   # becomes public
  def a2() end   # becomes public

  private
  def b1() end   # becomes private
  def b2() end   # becomes private

  protected
  def c1() end   # becomes protected
  def c2() end   # becomes protected
end
</pre>
<p>Here <code>public</code>, <code>private</code> and `protected are method calls without
parentheses. These aren&#8217;t reserved words.</p>
<p><code>public</code> and <code>private</code> can also be used with an argument to set
the visibility of a particular method. But that&#8217;s not really relevant.
We&#8217;ll leave this out.</p>
<h4>Module functions</h4>
<p>Given a module &#8216;M&#8217;. If there are two methods with the exact same
content</p>
<ul>
	<li><code>M.method_name</code></li>
	<li><code>M#method_name</code>(Visibility is <code>private</code>)</li>
</ul>
<p>then we call this a module function.</p>
<p>It is not apparent why this should be useful. But let&#8217;s look
at the next example which is happily used.</p>
<pre class="emlist">
Math.sin(5)       # If used for a few times this is more convenient

include Math
sin(5)            # If used more often this is more practical
</pre>
<p>It&#8217;s important that both functions have the same content.
With a different <code>self</code> but with the same code the behavior should
still be the same. Instance variables become extremely difficult to use.
Hence these methods are probably only used
for procedures like <code>sin</code>. That&#8217;s why they are called module functions.</p>
<h2>Iterators</h2>
<p>Ruby&#8217;s iterators differ a bit from Java&#8217;s or C++&#8217;s iterator classes
or &#8216;Iterator&#8217; design patterns. Precisely speaking those iterators
are exterior iterators. Ruby&#8217;s iterators are called interior iterators.
It&#8217;s difficult to understand from the definition so
let&#8217;s explain it with a concrete example.</p>
<pre class="emlist">
arr = [0,2,4,6.8]
</pre>
<p>This array is given and we want to access the elements in
order. In C style we would write the following.</p>
<pre class="emlist">
i = 0
while i &lt; arr.length
  print arr[i]
  i += 1
end
</pre>
<p>Using an iterator we can write:</p>
<pre class="emlist">
arr.each do |item|
  print item
end
</pre>
<p>Everything from <code>each do</code> to <code>end</code> is the call to an iterator method.
More precisely <code>each</code> is the iterator method and between
<code>do</code> and <code>end</code> is the iterator block.
The part between the vertical bars are the block parameters.
They are the arguments passed from the iterator method to the block where
they become variables.</p>
<p>Saying it quite abstractly, an iterator is something like
a piece of code which has been cut out and passed. In our example the
piece <code>print item</code> has been cut out and is passed to the <code>each</code> method.
Then <code>each</code> takes all the elements of the array in order and passes them
to the cut out piece of code.</p>
<p>We can also think the other way round. The other parts except <code>print item</code>
are being cut out and inserted into the <code>each</code> method.</p>
<pre class="emlist">
i = 0
while i &lt; arr.length
  print arr[i]
  i += 1
end

arr.each do |item|
  print item
end
</pre>
<h3>Comparison with higher order functions</h3>
<p>What comes closest in C to iterators are functions which receive function pointers,
or higher order functions. But there are two points in which iterators in Ruby
and higher order functions in C differ.</p>
<p>Firstly, Ruby iterators can only take one block. For instance we can&#8217;t
do the following.</p>
<pre class="emlist">
# Mistake. Several blocks cannot be passed.
array_of_array.each do |i|
  ....
end do |j|
  ....
end
</pre>
<p>Secondly, Ruby&#8217;s blocks can share local variables with the code outside.</p>
<pre class="emlist">
lvar = 'ok'
[0,1,2].each do |i|
  p lvar    # Can acces local variable outside the block.
end
</pre>
<p>That&#8217;s where iterators are convenient.</p>
<p>But variables can only be shared with the outside. They cannot be shared
with the inside of the iterator method ( e.g. <code>each</code>). Putting it intuitively,
only the local variables can be seen, which are on the  outside of the code.</p>
<h3>Block Local Variables</h3>
<p>Local variables which are assigned inside a block stay local to that block.
They become block local variables. Let&#8217;s check it out.</p>
<pre class="emlist">
[0].each do
  i = 0
  p i     # 0
end
</pre>
<p>For the time being we apply each to an array of length 1. ( We can
leave out the block parameter.) The variable <code>i</code> is first assigned
and declared inside the block. So <code>i</code> becomes a block local variable.</p>
<p>Block local means that it cannot be accessed from the outside.
Let&#8217;s test it.</p>
<pre class="screen">
% ruby -e '
[0].each do
  i = 0
end
p i     # Here occurs an error.
'
-e:5: undefined local variable or method `i'
for #&lt;Object:0x40163a9c&gt; (NameError)
</pre>
<p>When we referenced a block local variable from outside the block
an error occured. Without a doubt it stayed local to the block.</p>
<p>Iterators can also be nested repeatedly. Each time
the new block creates another scope.</p>
<pre class="emlist">
lvar = 0
[1].each do
  var1 = 1
  [2].each do
    var2 = 2
    [3].each do
      var3 = 3
      #  Here lvar, var1, var2, var3 can be seen
    end
    # Here lvar, var1, var2 can be seen
  end
  # Here lvar, var1 can be seen
end
# Here only lvar can be seen
</pre>
<p>There&#8217;s one point which you have to keep in mind. Differing from
nowadays&#8217; major languages Ruby&#8217;s block local variables don&#8217;t do shadowing.
Shadowing means for instance in C that in the code below the two declared
variables <code>i</code> are different.</p>
<pre class="emlist">
{
    int i = 3;
    printf("%d\n", i);         /* 3 */
    {
        int i = 99;
        printf("%d\n", i);     /* 99 */
    }
    printf("%d\n", i);         /* 3 (元に戻った) */
}
</pre>
<p>Inside the block the <code>i</code> inside overshadows the <code>i</code> outside.
That&#8217;s why it&#8217;s called shadowing.</p>
<p>But what happens in Ruby where there&#8217;s no shadowing.
Let&#8217;s look at this example.</p>
<pre class="emlist">
i = 0
p i           # 0
[0].each do
  i = 1
  p i         # 1
end
p i           # 1 the change is preserved
</pre>
<p>When we assign <code>i</code> inside the block and if there is a variable <code>i</code>
that same variable will be used. Hence if we assign to <code>i</code> inside
the value for <code>i</code> on the outside changes. On this point there
came many complains: &#8220;This is error prone. Please do shadowing.&#8221;
Each time there&#8217;s flaming but till now no conclusion was reached.</p>
<h3>The syntax of iterators</h3>
<p>There are some smaller topics left.</p>
<p>First, there are two ways to write an iterator. One is the
<code>do</code> ~ <code>end</code> as used above, the other one is the enclosing in braces.
The two expressions below have exactly the same meaning.</p>
<pre class="emlist">
arr.each do |i|
  puts i
end

arr.each {|i|    # The author likes a four space indentation for
    puts i       # an iterator with braces.
}
</pre>
<p>But grammaticarly the precedence is different.
The braces bind much stronger than <code>do</code>~<code>end</code>.</p>
<pre class="emlist">
m m do .... end    # m(m) do....end
m m { .... }       # m(m() {....})
</pre>
<p>And iterators are of course just methods so they also take
arguments.</p>
<pre class="emlist">
re = /^\d/                 # regular expression to match a digit at the beginning of the line
$stdin.grep(re) do |line|  # look repeatedly for this regular expression
  ....
end
</pre>
<h3><code>yield</code></h3>
<p>Of course users can write their own iterators. Methods which have
a <code>yield</code> in their definition text are iterators.
Let&#8217;s try to write an iterator with the same effect as <code>Array#each</code>:</p>
<pre class="emlist">
# adding the definition to the Array class
class Array
  def my_each
    i = 0
    while i &lt; self.length
      yield self[i]
      i += 1
    end
  end
end

# this is the original each
[0,1,2,3,4].each do |i|
  p i
end

# my_each works the same
[0,1,2,3,4].my_each do |i|
  p i
end
</pre>
<p><code>yield</code> calls the block. At this point control is passed to the block,
when the execution of the block finishes it returns back to the same
location. Think about it like calling a special function. When the
present method does not have a block a runtime error will occur.</p>
<pre class="screen">
% ruby -e '[0,1,2].each'
-e:1:in `each': no block given (LocalJumpError)
        from -e:1
</pre>
<h3><code>Proc</code></h3>
<p>I said, that iterators are like cut out code which is passed as an
argument. But we can even more directly make code to an object
and carry it around.</p>
<pre class="emlist">
twice = Proc.new {|n| n * 2 }
p twice.call(9)   # 18 will be printed
</pre>
<p>In short, it is like a function. It can be created with <code>new</code> and
as might be expected, the return value of <code>Proc.new</code> is an instance
of the <code>Proc</code> class.</p>
<p><code>Proc.new</code> looks surely like an iterator and it is indeed so.
It is an ordinary iterator. There&#8217;s only some mechanism inside <code>Proc.new</code>
which turns an iterator block into an object.</p>
<p>Besides there is a function style method <code>lambda</code> provided which
has the same effect as <code>Proc.new</code>. Choose whatever suits you.</p>
<pre class="emlist">
twice = lambda {|n| n * 2 }
</pre>
<h4>Iterators and <code>Proc</code></h4>
<p>Why did we start talking all of a sudden about <code>Proc</code>? Because there
is a deep relationship between iterators and <code>Proc</code>.
In fact iterators and <code>Proc</code> objects are quite the same thing.
That&#8217;s why one can be transformed into the other.</p>
<p>First, to turn an iterator block into a <code>Proc</code> object
one has to put an <code>&amp;</code> in front of the parameter name.</p>
<pre class="emlist">
def print_block( &amp;block )
  p block
end

print_block() do end   # Shows something like &lt;Proc:0x40155884&gt;
print_block()          # Without a block nil is printed
</pre>
<p>With an <code>&amp;</code> in front of the argument name, the block is transformed to
a <code>Proc</code> object and assigned to the variable. If the method is not an
iterator (there&#8217;s no block attached) <code>nil</code> is assigned.</p>
<p>And in the other direction, if we want to pass a <code>Proc</code> to an iterator
we also use <code>&amp;</code>.</p>
<pre class="emlist">
block = Proc.new {|i| p i }
[0,1,2].each(&amp;block)
</pre>
<p>This code means exactly the same as the code below.</p>
<pre class="emlist">
[0,1,2].each {|i| p i }
</pre>
<p>If we combine these two, we can delegate an iterator
block to a method somewhere else.</p>
<pre class="emlist">
def each_item( &amp;block )
  [0,1,2].each(&amp;block)
end

each_item do |i|    # same as [0,1,2].each do |i|
  p i
end
</pre>
<h2>Expressions</h2>
<p>Expressions in Ruby can be combined to build new expressions or statements.
For instance a method call can be another method call&#8217;s argument,
and so it would become an expression.
The same goes for literals. But literals and method calls are not combinations
of other elements. From here on the expressions introduced will always be used
in combination with other expressions.</p>
<h3><code>if</code></h3>
<p>We probably do not need to explain the <code>if</code> expression. If the conditional
expression is true the body expression is executed. As explained in the
first part in Ruby every object except <code>nil</code> and <code>false</code> is true.</p>
<pre class="emlist">
if cond0 then
  ....
elsif cond1 then
  ....
elsif cond2 then
  ....
else
  ....
end
</pre>
<p><code>elsif</code> and <code>else</code> can be omitted. Each <code>then</code> can also be omitted
<code>elsif</code>・But there are some finer requirements concerning <code>then</code>.
It will be apparent by looking at the examples below.
All of them are valid.</p>
<pre class="emlist">
# 1                                    # 4
if cond then ..... end                 if cond
                                       then .... end
# 2
if cond; .... end                      # 5
                                       if cond
# 3                                    then
if cond then; .... end                   ....
                                       end
</pre>
<p>Furthermore, as every expression has a return value, there
is also a return value here. It is the return value of the
body expression which holds. For instance if the condition
at the beginning is true it is the return value of the
following expression.</p>
<pre class="emlist">
p(if true  then 1 else 2 end)   #=&gt; 1
p(if false then 1 else 2 end)   #=&gt; 2
p(if false then 1 elsif true then 2 else 3 end)   #=&gt; 2
</pre>
<p>If there&#8217;s no match, or the match is empty <code>nil</code> is returned.</p>
<pre class="emlist">
p(if false then 1 end)    #=&gt; nil
p(if true  then   end)    #=&gt; nil
</pre>
<h3><code>unless</code></h3>
<p>An <code>if</code> with a negated condition is the same as an <code>unless</code>.
The following two examples have the same meaning.</p>
<pre class="emlist">
unless cond then          if not (cond) then
  ....                      ....
end                       end
</pre>
<p><code>unless</code> can also have an <code>else</code> clause but there cannot be an <code>elsif</code>.
Of course <code>then</code> can be omitted.</p>
<p><code>unless</code> also has a value. Analogous to <code>if</code> it is the value of the of the
clause which matches. If there&#8217;s no match or the match is empty <code>nil</code>
is returned.</p>
<h3><code>and &amp;&amp; or ||</code></h3>
<p>The most useful utilization of the <code>and</code> is probably as a boolean operator.
For instance in the conditional clause of an <code>if</code>.</p>
<pre class="emlist">
if cond1 and cond2
  puts 'ok'
end
</pre>
<p>But as in Perl, the Shell or Lisp it can also be used as a conditional
branch expression.
The two following expressions have the same meaning.</p>
<pre class="emlist">
                                        if invalid?(key)
invalid?(key) and return nil              return nil
                                        end
</pre>
<p><code>&amp;&amp;</code> and <code>and</code> have the same meaning. Different is the binding order.</p>
<pre class="emlist">
method arg0 &amp;&amp;  arg1    # method(arg0 &amp;&amp; arg1)
method arg0 and arg1    # method(arg0) and arg1
</pre>
<p>Basically the symbolic operator is used in an expression which becomes an argument.
The alphabetical operator is used in an expression which will not become
an argument.</p>
<p>As for <code>and</code>, if the evaluation of the left hand side is true,
the right hand side will also be evaluated.</p>
<p>On the other hand <code>or</code> is the opposite of <code>and</code>. If the evaluation of the left hand
side is false, the right hand side will also be evaluated.</p>
<pre class="emlist">
valid?(key) or return nil
</pre>
<p><code>or</code> and <code>||</code> have the same relationship as <code>&amp;&amp;</code> and <code>and</code>. Only the precedence is
different.</p>
<h3>The Conditional Operator</h3>
<p>There is a conditional operator similar to C:</p>
<pre class="emlist">
cond ? iftrue : iffalse
</pre>
<p>The space between the symbols is important.
If they bump together the following weirdness happens.</p>
<pre class="emlist">
cond?iftrue:iffalse   # cond?(iftrue(:iffalse))
</pre>
<p>The value of the conditional operator is the value of the last executed expression.
Either the value of the true side or the value of the false side.</p>
<h3><code>while until</code></h3>
<p>Here&#8217;s a <code>while</code> expression.</p>
<pre class="emlist">
while cond do
  ....
end
</pre>
<p>This is the most basic loop construct. As long as <code>cond</code> is true
the body is executed. The <code>do</code> can be omitted.</p>
<pre class="emlist">
until io_ready?(id) do
  sleep 0.5
end
</pre>
<p><code>until</code> comes to the exact opposite conclusion as the <code>while</code>.
As long as the body expression is false it is executed.
The <code>do</code> can be omitted.</p>
<p>There is also a jump construct which exits the loop.
As in C/C++/Java it is called <code>break</code>. Instead of <code>continue</code> there
is <code>next</code>. That seems to have come from Perl.</p>
<pre class="emlist">
i = 0
while true
  if i &gt; 10
    break   # exit the loop
  elsif i % 2 == 0
    i *= 2
    next    # next loop iteration
  end
  i += 1
end
</pre>
<p>And there is another Perlism: the <code>redo</code>.</p>
<pre class="emlist">
while cond
  # (A)
  ....
  redo
  ....
end
</pre>
<p>It will return to <code>(A)</code> and repeat from there. With next there
is a condition <code>check</code>, with <code>redo</code> there is none.</p>
<p>I might come into the world top 100, if the amount of Ruby programs
would be counted, but I haven&#8217;t used <code>redo</code> yet. It does not seem to be
that necessary after all.</p>
<h3><code>case</code></h3>
<p>A special form of the <code>if</code> expression. It performs branching on a series of
conditions. The following left and right expressions are identical in meaning.</p>
<pre class="emlist">
case value
when cond1 then                if cond1 === value
  ....                           ....
when cond2 then                elsif cond2 === value
  ....                           ....
when cond3, cond4 then         elsif cond3 === value or cond4 === value
  ....                           ....
else                           else
  ....                           ....
end                            end
</pre>
<p>The threefold equals <code>===</code> is, as the same as the <code>==</code>, actually a method call.
Notice that the receiver is the object on the left hand side. Concretely,
if it is the <code>===</code> of an <code>Array</code>, it would check if it contains the <code>value</code>
as its element.
If it is a <code>Hash</code>, it tests whether it has the <code>value</code> as its key.
If its is an regular expression, it tests if the <code>value</code> matches.
And so on.
Since <code>case</code> has many grammatical elements,
to list them all would be tedious, thus we will not cover them in this book.</p>
<h3>Exceptions</h3>
<p>This is a  control structure which can pass method boundaries and
transmit errors. Readers who are acquainted to C++ or Java
will know about exceptions. Ruby exceptions are basically the
same.</p>
<p>In Ruby exceptions come in the form of the function style method <code>raise</code>.
<code>raise</code> is not a reserved word.</p>
<pre class="emlist">
raise ArgumentError, "wrong number of argument"
</pre>
<p>In Ruby exception are instances of the <code>Exception</code> class and it&#8217;s
subclasses. This form takes an exception class as its first argument
and an error message as its second argument. In the above case
an instance of <code>ArgumentError</code> is created and &#8220;thrown&#8221;. Exception
object ditch the part after the <code>raise</code> and return upwards the
method call stack.</p>
<pre class="emlist">
def raise_exception
  raise ArgumentError, "wrong number of argument"
  # the code after the exception will not be executed
  puts 'after raise'
end
raise_exception()
</pre>
<p>If nothing blocks the exception it will move to the top level.
When it reaches the top level, <code>ruby</code> gives out a message and ends
with a non-zero exit code.</p>
<pre class="screen">
% ruby raise.rb
raise.rb:2:in `raise_exception': wrong number of argument (ArgumentError)
        from raise.rb:7
</pre>
<p>However, for this an <code>exit</code> would be sufficient, for an exception ther
should be ways to handle it. In Ruby there is the <code>begin</code>, <code>rescue</code>, <code>end</code> for this.
It resembles the <code>try</code> and <code>catch</code> in C++ and Java.</p>
<pre class="emlist">
def raise_exception
  raise ArgumentError, "wrong number of argument"
end

begin
  raise_exception()
rescue ArgumentError =&gt; err then
  puts 'exception catched'
  p err
end
</pre>
<p><code>rescue</code> is a control structure which captures an exception, it catches
the exceptions of the declared class and its subclasses. If in the
above example an instance of <code>ArgumentError</code> comes flying this <code>rescue</code>
matches it. By <code>=&gt;err</code> the exception object will be assigned to the local variable
<code>err</code>, after that the <code>rescue</code> part is executed.</p>
<pre class="screen">
% ruby rescue.rb
exception catched
#&lt;ArgumentError: wrong number of argument&gt;
</pre>
<p>If the exception is resuced the execution carries on after the rescue
as if nothing happened. We can also make it retry the critical part
with <code>retry</code>.</p>
<pre class="emlist">
begin    # return here
  ....
rescue ArgumentError =&gt; err then
  retry  # beginning anew
end
</pre>
<p>We can omit the <code>=&gt;err</code> and the <code>then</code> after <code>rescue</code>. We can also leave
out the exception class. In this case the class <code>StandardError</code> is matched.</p>
<p>If we want to add more exception classes we can just list them after <code>rescue</code>.
When we want to handle different errors differently we can use several <code>rescue</code>s
in one <code>begin</code>~<code>end</code> block.</p>
<pre class="emlist">
begin
  raise IOError, 'port not ready'
rescue ArgumentError, TypeError
rescue IOError
rescue NameError
end
</pre>
<p>In this case the exception class is checked in order until there is a match.
Only the one matched part is executed. For instance in the above case only
<code>IOError</code> is executed.</p>
<p>On the othor hand, when there is an <code>else</code> clause, it is executed
only when there is no exception.</p>
<pre class="emlist">
begin
  nil    # Of course here will no error occur
rescue ArgumentError
  # This part will not be executed
else
  # This part will be executed
end
</pre>
<p>Moreover an <code>ensure</code> clause will be executed in every case:
when there is no exception, when there is an exception, rescued or not.</p>
<pre class="emlist">
begin
  f = File.open('/etc/passwd')
  # do stuff
ensure   # this part will be executed anyway
  f.close
end
</pre>
<p>Besides, this <code>begin</code> expression also has a value. The value of the
whole <code>begin</code>~<code>end</code> expression is the value of the part which was executed
last. The <code>ensure</code> part does not count as it is normally used for cleanup only.</p>
<h3>Variables and Constants</h3>
<p>Referring a variable or a constant. The value is the object the variable points to.
We already talked in too much detail about the various behaviors.</p>
<pre class="emlist">
lvar
@ivar
@@cvar
CONST
$gvar
</pre>
<p>I want to add one more thing. The variables starting with <code>$</code> are
of a special kind. Some have strange names, but they are not
necessarily global.</p>
<p>First the Perlish variables <code>$_</code> and <code>$~</code>. <code>$_</code> saves the return
value of <code>gets</code> and other methods, <code>$~</code> contains the last match
of a regular expression. They are called local and thread local.
Incredible variables.</p>
<p>And the variable <code>$!</code> which saves the exceptional object when
an exception has occurred as well as the variable <code>$?</code> which
saves the status of a child process and <code>$SAFE</code> which represents
the security level are all thread local.</p>
<h3>Assignment</h3>
<p>Variable assignment are all performed by <code>=</code>. All variables are
typeless. What is saved is a reference to an object. It is
implemented with <code>VALUE</code> (pointer).</p>
<pre class="emlist">
var = 1
obj = Object.new
@ivar = 'string'
@@cvar = ['array']
PI = 3.1415926535
$gvar = {'key' =&gt; 'value'}
</pre>
<p>However, as mentioned earlier <code>obj.attr=val</code> is not an assignment.
It is a method call.</p>
<h3>Self Assignment</h3>
<pre class="emlist">
var += 1
</pre>
<p>This syntax is also in C/C++/Java. In Ruby,</p>
<pre class="emlist">
var = var + 1
</pre>
<p>it is a shortcut of this code.
Differing from C, the Ruby <code>+</code> is a method and thus part of the library.
In the whole meaning of <code>+=</code> is built in the language processor itself.
And in <code>C++</code>, <code>+=</code> and <code>*=</code> can be wholly overwritten,
but we cannot do this in Ruby.
In Ruby <code>&lt;code&gt;=</code> is always defined as an operation of the combination of <code>&lt;/code&gt;</code> and assignment.</p>
<p>We can also combine self assignment and an attribute-access-flavor method.
The result more looks like an attribute.</p>
<pre class="emlist">
class C
  def i() @i end          # A method definition can be written in one line.
  def i=(n) @i = n end
end

obj = C.new
obj.i = 1
obj.i += 2    # obj.i = obj.i + 2
p obj.i       # 3
</pre>
<p>If there is <code>+=</code> there might also be <code>++</code> but this is not the case.
Why is that so? In Ruby assignment is dealt with on the language level.
But on the other hand methods are in the library. Keeping these two,
the world of variables and the world of objects, strictly apart is an
important peculiarity of Ruby. If <code>++</code> were introduced the separation
might easily be broken. That&#8217;s why there&#8217;s no <code>++</code></p>
<p>Some people don&#8217;t want to go without the brevity of <code>++</code>. It has been
proposed again and again in the mailing list but was always turned down.
I also am in favor of <code>++</code> but I can do without, there has never been
a <code>++</code> in Ruby so let&#8217;s forget about it.</p>
<h3><code>defined?</code></h3>
<p><code>defined?</code> is a strange construct in Ruby. It tells whether an
expression value is defined or not.</p>
<pre class="emlist">
var = 1
defined?(var)   #=&gt; true
</pre>
<p>In other words it tells whether the received argument (is it okay to call
it so?) returns a value after evaluation. But it won&#8217;t tell you if there&#8217;s
a parse error or an exception is raised.</p>
<p>I would have loved to tell you more about <code>defined?</code>
but it will not appear again in this book. What a pity.</p>
<h2>Statements</h2>
<p>A statement is a syntactic construct which basically
cannot be combined with something else and is written
in a separate line.</p>
<p>But it still can be evaluated. For instance there are return values
for class definition statements and method definition statements.
However this is only rarely used, not recommended and isn&#8217;t useful.
We stick with this informal criteria.
Here we also don&#8217;t mention the various return values.</p>
<h3>The Ending of a statement</h3>
<p>Up to now we just said &#8220;For now one line&#8217;s one statement&#8221;.
But Ruby&#8217;s statement ending&#8217;s aren&#8217;t that straightforward.</p>
<p>First a statement can be ended explicitly with a semicolon as in C.
Of course then we can write two and more statements in one line.</p>
<pre class="emlist">
puts 'Hello, World!'; puts 'Hello, World once more!'
</pre>
<p>On the other hand after opened parentheses, dyadic operators, or commas
when the command apparently continues the sentence continues automatically.</p>
<pre class="emlist">
# 1 + 3 * method(6, 7 + 8)
1 +
  3 *
     method(
            6,
            7 + 8)
</pre>
<p>But it&#8217;s also no problem to connect lines explicitly with a backslash.</p>
<pre class="emlist">
p 1 + \
  2
</pre>
<h3>The Modifiers <code>if</code> and <code>unless</code></h3>
<p>The <code>if</code> modifier is an irregular version of the normal <code>if</code>
The programs on the left and right mean exactly the same.</p>
<pre class="emlist">
on_true() if cond                if cond
                                   on_true()
                                 end
</pre>
<p>The <code>unless</code> is the negative version.
Guard statements ( statements which exclude exceptions) can
be conveniently written with it.</p>
<h3>The Modifiers <code>while</code> and <code>until</code></h3>
<p><code>while</code> and <code>until</code> also have a back notation.</p>
<pre class="emlist">
process() while have_content?
sleep(1) until ready?
</pre>
<p>Combining this with <code>begin</code> and <code>end</code> gives a <code>do</code>-<code>while</code>-loop like in C.</p>
<pre class="emlist">
begin
  res = get_response(id)
end while need_continue?(res)
</pre>
<h3>Class Definition</h3>
<pre class="emlist">
class C &lt; SuperClass
  ....
end
</pre>
<p>Defines the class <code>C</code> which inherits from <code>SuperClass</code></p>
<p>We talked quite extensively about classes in the first part.
This statement will be executed, within the definition the class will
become <code>self</code>, arbitrary expressions can be written within. Class
definitions can be nested. They form the foundation of Ruby execution
image.</p>
<h3>Method Definition</h3>
<pre class="emlist">
def m(arg)
end
</pre>
<p>I&#8217;ve already written about method definition and won&#8217;t add more.
They also belong to statements.</p>
<h3>Singleton method definition</h3>
<p>We already talked a lot about singleton methods in the first part.
They do not belong to classes but to objects, in fact, they belong
to singleton classes. We define singleton methods by putting the
receiver in front of the method name. Parameter declaration is done
the same way like with ordinary methods.</p>
<pre class="emlist">
def obj.some_method
end

def obj.some_method2( arg1, arg2, darg = nil, *rest, &amp;block )
end
</pre>
<h3>Definition of Singleton methods</h3>
<pre class="emlist">
class &lt;&lt; obj
  ....
end
</pre>
<p>From the viewpoint of purposes,
it is the statement to define some singleton methods in a bundle.
From the viewpoint of measures,
it is the statement in which the singleton class of <code>obj</code> becomes <code>self</code> when
executed.
In all over the Ruby program,
this is the only place where a singleton class is exposed.</p>
<pre class="emlist">
class &lt;&lt; obj
  p self  #=&gt; #&lt;Class:#&lt;Object:0x40156fcc&gt;&gt;   # Singleton Class 「(obj)」
  def a() end   # def obj.a
  def b() end   # def obj.b
end
</pre>
<h3>Multiple Assignment</h3>
<p>With a multiple assignment several assignments can be combined into one.
The following is a simple example:</p>
<pre class="emlist">
a, b, c = 1, 2, 3
</pre>
<p>It&#8217;s exactly the same as the following.</p>
<pre class="emlist">
a = 1
b = 2
c = 3
</pre>
<p>It&#8217;s not just for brevity&#8217;s sake. When we bind variables to an elements
of an array it becomes delightful.</p>
<pre class="emlist">
a, b, c = [1, 2, 3]
</pre>
<p>This also has the same result as the above.
Furthermore, the right handside does not need to be a literal.
It can also be a variable or a method call.</p>
<pre class="emlist">
tmp = [1, 2, 3]
a, b, c = tmp
ret1, ret2 = some_method()   # some_method might probably return several values
</pre>
<p>Precisely speaking it is as follows. We will write the value of the
left hand side as <code>obj</code>.</p>
<ol>
	<li><code>obj</code> if it is an array</li>
	<li>if its <code>to_ary</code> method is defined, it is used to convert <code>obj</code> to an array.</li>
	<li><code>[obj]</code></li>
</ol>
<p>Decide the right-hand side by following this procedure and perform assignments.
It means the evaluation of the right-hand side and the operation of assignments
are totally independent from each other.</p>
<p>And it goes on, the left and right hand side can be infinitely nested.</p>
<pre class="emlist">
a, (b, c, d) = [1, [2, 3, 4]]
a, (b, (c, d)) = [1, [2, [3, 4]]]
(a, b), (c, d) = [[1, 2], [3, 4]]
</pre>
<p>As the result of the execution of this program,
each line will be <code>a=1 b=2 c=3 d=4</code>.</p>
<p>And it goes on. The left hand side can be index or parameter assignments.</p>
<pre class="emlist">
i = 0
arr = []
arr[i], arr[i+1], arr[i+2] = 0, 2, 4
p arr    # [0, 2, 4]

obj.attr0, obj.attr1, obj.attr2 = "a", "b", "c"
</pre>
<p>And like with method parameters,
<code>*</code> can be used to receive in a bundle.</p>
<pre class="emlist">
first, *rest = 0, 1, 2, 3, 4
p first  # 0
p rest   # [1, 2, 3, 4]
</pre>
<p>If all of them are used all at once, you will easily get confused.</p>
<h4>Block parameter and multiple assignment</h4>
<p>We brushed over block parameters when we were talking about iterators.
But there is a deep relationship between them and multiple assignment.
For instance in the following case.</p>
<pre class="emlist">
array.each do |i|
  ....
end
</pre>
<p>When the block is called with a <code>yield</code>, the provided parameters are multi-assigned to <code>i</code>.
Here there&#8217;s only one variable on the left hand side, so it does not look like multi assignment.
But if there are two or more variables we see what&#8217;s going on. For instance <code>Hash#each</code>
provides a key and a value we usually call it like that:</p>
<pre class="emlist">
hash.each do |key, value|
  ....
end
</pre>
<p>In this case an array with elements key and value are yielded
from the hash.</p>
<p>Hence we can also use nested multiple assignment as shown below.</p>
<pre class="emlist">
# [[key,value],index] are given to yield
hash.each_with_index do |(key, value), index|
  ....
end
</pre>
<h3><code>alias</code></h3>
<pre class="emlist">
class C
  alias new orig
end
</pre>
<p>Defining another method <code>new</code> with the same body as the already
defined method <code>orig</code>. <code>alias</code> are similar to hardlinks in a unix
file system. They are a means of assigning multiple names to one method body. I other words,
because the names themselves are independent of each other,
if one method name is overwritten by a subclass method, the
other one still returns the method as before.</p>
<h3><code>undef</code></h3>
<pre class="emlist">
class C
  undef method_name
end
</pre>
<p>Prohibits the calling of <code>C#method_name</code>. It&#8217;s not just a simple
revoking of the definition. If there even were a method in the
superclass it would also be forbidden. In other words the method is
exchanged for a sign which says &#8220;This method must not be called&#8221;.</p>
<p><code>undef</code> is extremely powerful, once it is set it cannot be
deleted on the Ruby level, because it is used to cover up contradictions
in the internal structure. One must define a method in the lower class.
Even then when one calls <code>super</code> an
error occurs.</p>
<p>By the way the method which corresponds to <code>unlink</code> in a file system
is <code>Module#remove_method</code>. While defining a class, <code>self</code> refers
to that class, we can call it as follows ( Remember that <code>Class</code> is a
subclass of <code>Module</code>.</p>
<pre class="emlist">
class C
  remove_method(:method_name)
end
</pre>
<p>But even with a <code>remove_method</code> one cannot cancel the <code>undef</code>.
It&#8217;s because the sign put up by <code>undef</code> prohibits any kind of searches.</p>
<p>((errata: It can be redefined by using <code>def</code>))</p>
<h2>Some more small topics</h2>
<h3>Comments</h3>
<pre class="emlist">
# examples of bad comments.
1 + 1            # compute 1+1.
alias my_id id   # my_id is an alias of id.
</pre>
<p>From a <code>#</code> to the end of line is a comment.
It doesn&#8217;t have a meaning for the program.</p>
<h3>Embedded documents</h3>
<pre class="emlist">
=begin
This is an embedded document.
It's so called because it is embedded in the program.
Plain and simple.
=end
</pre>
<p>An embedded document stretches from
an <code>=begin</code> outside a string at the beginning of a line
to a <code>=end</code>. The interior can be arbitrary.
The program reads and ignores it like a simple comment.</p>
<h3>Multi-byte strings</h3>
<p>When the global variable <code>$KCODE</code> is set to either <code>EUC</code>, <code>SJIS</code>
or <code>UTF8</code>, strings encoded in euc-jp, shift_jis, or utf8 respectively can be
used in a string of a data.</p>
<p>And if the option <code>-Ke</code>, <code>-Ks</code> or <code>-Ku</code> is given to the <code>ruby</code>
command multibyte strings can be used within the Ruby code.
String literals, regular expressions and even operator names
can contain multibyte characters. Hence it is possible to do
something like this:</p>
<pre class="emlist">
def 表示( arg )
  puts arg
end

表示 'にほんご'
</pre>
<p>But I really cannot recommend doing things like that.</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
