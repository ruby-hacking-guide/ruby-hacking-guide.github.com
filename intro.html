<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>  Introduction - translation in progress |  Ruby Hacking Guide </title>
  <link rel="stylesheet" href="/css/styles.css" />
</head>
<body>

  <div id="main">

    <header>
      <h1><a href="/">Ruby Hacking Guide</a></h1>
    <header>

    <nav role="navigation">
      <ul>
      </ul>
    </nav>

    <h1>Preface: Introduction
h2. Characteristics of Ruby</h1>
<p>Some of the readers may have already been familiar with Ruby, some may be not.
(I wish the latter for this chapter to be most useful) First let&#8217;s go though a
rough summary of the characteristics of Ruby for such people.</p>
<p>Hereafter capital &#8220;Ruby&#8221; refers to Ruby as a language scheme, and lowercase
&#8220;<code>ruby</code>&#8221; refers to the implementation of <code>ruby</code> command.</p>
<h4>Development pattern</h4>
<p>Ruby is a personally created language by Yukihiro Matsumoto.  That means Ruby
doesn&#8217;t have a standard scheme that C or Java have. The specification is merely
shown as an implementation as <code>ruby</code>, and its varying continuously. Whichever
you mention good or bad, it&#8217;s unbind.</p>
<p>Furthermore <code>ruby</code> itself is a free software  &#8211;  source code being open and
being in public free of charge  &#8211;  this is what I must add in the introduction.
That&#8217;s why it allows the approach of this book into publication.</p>
<p>Giving the <code>README</code> and <code>LEGAL</code> included in the distribution package the
complete reading of the license, let&#8217;s list up what you can do for the time
being:</p>
<p>You can redistribute source code of <code>ruby</code>
You can modify source code of <code>ruby</code>
You can redistribute a copy of source code with your modification</p>
<p>There is no need for special permission and payment in all these cases.</p>
<p>By the way, the original <code>ruby</code> is the version referred to in this book unless
otherwise stated, because our main purpose is to read it. However, I modified
the code without notice at a certain extent such as to remove or add white
spaces, new lines, and comments.</p>
<h4>It&#8217;s conservative</h4>
<p>Ruby is a very conservative language. It is equipped with only carefully chosen
features that have been tested and washed out in a variety of languages​.
Therefore it doesn&#8217;t have plenty of fresh and experimental features very much.
So it has a tendency to appeal to programmers who put importance on practical
functionalities. The dyed-in-the-wool hackers like Scheme and Haskell lovers
don&#8217;t seem to find appeal in ruby in a short glance.</p>
<p>The library is conservative in the same way. Clear and unabbreviated names are
given for new functions, while names that appears in C and Perl libraries have
been took over from them. For example, <code>printf</code>, <code>getpwent</code>, <code>sub</code>, and <code>tr</code>.</p>
<p>It is also conservative in implementation. Assembler is not its option for
seeking speed. Portability is always considered a higher priority when it
conflicts with speed.</p>
<h4>It is an object-oriented language</h4>
<p>Ruby is an object-oriented language. It is not possible to forget about it
absolutely, when you talk about the features of Ruby.</p>
<p>I will not give a page to this book about what an object-oriented language is.
To tell about an object-oriented feature about Ruby, the expression of the code
that just going to be explained below is the exact sample.</p>
<h4>It is a script language</h4>
<p>Ruby is a script language. It is also not possible to forget about it
absolutely, when you talk about the features of Ruby. To gain agreement of
everyone, an introduction of Ruby must include &#8220;object-oriented&#8221; and &#8220;script
language&#8221;.</p>
<p>However, what is a &#8220;script language&#8221; for example? I couldn&#8217;t figure out the
definition successfully. For example, John K. Ousterhout, the author of Tcl/Tk,
gives a definition as &#8220;executable language using <code>#!</code> on <span class="caps">UNIX</span>&#8221;. There are other
definitions depending on the view points, such as one that can express a useful
program with only one line, or that can execute the code by passing a program
file from the command line, etc.</p>
<p>However, I dare to use another definition, because I don&#8217;t find much interest
in &#8220;what&#8221; a script language. To call it a script language, it at least has to
avoid gaining disagreement of calling it so. That&#8217;s the definition I suggest.
To fulfill this definition, I would define the meaning of &#8220;script language&#8221; as
follows.</p>
<p>p(=center). 
Whether the author of the language calls it &#8220;script language&#8221; or not.</p>
<p>I&#8217;m sure this definition will have no failure. And Ruby fulfills this point. 
Therefore I call Ruby a &#8220;script language&#8221;.</p>
<h4>It&#8217;s an interpreter</h4>
<p><code>ruby</code> is an interpreter. That&#8217;s the fact. But why it&#8217;s an interpreter?  For
example, couldn&#8217;t it be made as a compiler? The answer should be &#8220;no&#8221;, because
I guess Ruby has at least something better than being an interpreter than a
compiler. Well, what is good about being an interpreter?</p>
<p>As a preparation step to investigating into it, let&#8217;s start by thinking about
the difference between an interpreter and a compiler. If the matter is to
attempt a comparison with the process how a program is executed theoretically,
there&#8217;s no difference between an interpreter language and a compile language.
It may be possible to say that a compiler language involves an interpreter,
because of the fact that <span class="caps">CPU</span> &#8220;interprets&#8221; a code into a machine language using
a compiler. What&#8217;s the difference actually?  I suppose it&#8217;s in a practical
things  &#8211;  in the process of development.</p>
<p>I know somebody, as soon as hearing &#8220;in the process of development&#8221;, would
claim using a stereotypical phrase, that an interpreter reduces effort of
compilation that makes the development procedure easier. But I don&#8217;t think it&#8217;s
accurate. A language could possibly be planned so that it won&#8217;t show the
process of compilation. Actually, Delphi can compile a project by hitting just
F5. A claim about a long time for compilation is derived from the size of the
project or optimization of the codes. Compilation itself doesn&#8217;t owe a negative
side.</p>
<p>Well, why people perceive an interpreter and compiler so much different like
this? I think that it is because the developers have long distinguished the use
of the implementations of these languages according to the characteristics. In
short, a comparatively small, a daily routine fits well with developing an
interpreter language. On the other hand, a compiler language is a goal for a
large project where a number of people are involved in the development and
accuracy is required. That may be because of the speed, as well as the
readiness of creating a language.</p>
<p>Therefore, &#8220;it&#8217;s handy because it&#8217;s an interpreter&#8221; is merely an outsized myth.
Being an interpreter doesn&#8217;t necessarily contribute the readiness in usage;
seeking readiness in usage naturally makes your path toward building an
interprer language.</p>
<p>Anyway, <code>ruby</code> is an interpreter; it has an important fact about where this
book is facing, so I emphasize it here again. It doesn&#8217;t matter whether it&#8217;s
easy being an interpreter; anyway <code>ruby</code> is implemented as an interpreter.</p>
<h4>High portability</h4>
<p>Even with a fundamental problem that the interface is built targeting Unix, I
would insist <code>ruby</code> possesses a high portability. It doesn&#8217;t often require an
unfamiliar library. It doesn&#8217;t have a part written in assembler gorigorily.
Therefore it&#8217;s easy to port to a new platform, comparatively. Namely, it works
on the following platforms currently.</p>
<p>Linux
Win32 (Windows 95, 98, Me, NT, 2000, XP)
Cygwin
djgpp
FreeBSD
NetBSD
OpenBSD
<span class="caps">BSD</span>/OS
Mac OS X
Solaris
Tru64 <span class="caps">UNIX</span>
HP-UX
<span class="caps">AIX</span>
<span class="caps">VMS</span>
UX/4800
BeOS
OS/2 (emx)
Psion</p>
<p>The main machine of the author Matsumoto is Linux, reportedly. You can assume
that a Linux will not fail to build any version of ruby.</p>
<p>Furthermore, a typical Unix environment basically can expect a stable
functionality. Considering the release cycle of packages, the primary option
for the environment to hit around <code>ruby</code> should fall on a branch of PC <span class="caps">UNIX</span>,
  currently.</p>
<p>On the other hand, the Win32 environment tends to cause problems definitely.
The large gaps in the targeting OS model tend to cause problems around the
machine stack and the linker. Yet, recently Windows hackers have contributed to
make better support. I use a native ruby on Windows 2000 and Me. Once it gets
successfully run, it doesn&#8217;t seem to show special concerns like frequent
crashing. The main problems on Windows may be the gaps in the specifications.</p>
<p>Another type of OS that many people may be interested in should probably be Mac
OS (prior to v9) and handheld OS like Palm.</p>
<p>Around <code>ruby 1.2</code> and before, it supported legacy Mac OS, but the development
seems to be in suspension. Even a compiling can&#8217;t get through. The biggest
cause is that the compiler environment of legacy Mac OS and the decrease of
developers. Talking about Mac OS X, there&#8217;s no worries because the body is
<span class="caps">UNIX</span>.</p>
<p>There seem to be discussions the portability to Palm several branches, but I
have never heard of a successful project. I guess the difficulty lies in the
necessity of settling down the specification-level standards such as <code>stdio</code> on
the Palm platform, rather than the processes of actual implementation. Well I
saw a porting to Psion has been done. ([ruby-list:36028]).</p>
<p>How about hot stories about VM seen in Java and .<span class="caps">NET</span>? I need to mention these
together with implementation in the final chapter.</p>
<h4>Automatic memory control</h4>
<p>Functionally it&#8217;s called GC, or Garbage Collection. Saying it in C-language,
this feature allows you to skip <code>free()</code> after <code>malloc()</code>.  Unused memory is
detected by the system automatically, and will be released. It&#8217;s so convenient
that once you get used to GC you will likely be unwilling to do it manual
memory control again.</p>
<p>The topics about GC have been common because of its popularity in recent
languages with GC as a standard set, and the GS is fun to talk about because it
has a lot to devise better algorithms.</p>
<h4>Typeless variables</h4>
<p>The variables in Ruby don&#8217;t have types. The reason is probably typeless
variables conforms more with polymorphism, which is one of the strongest
features of an object-oriented language.  Of course a language with variable
type has a way to deal with polymorphism.  What I mean here is a typeless
variables have better conformance.</p>
<p>The level of &#8220;better conformance&#8221; in this case refers to synonyms like &#8220;handy&#8221;.
It&#8217;s sometimes corresponds to crucial importance, sometimes it doesn&#8217;t matter
practically. Yet, this is certainly an appealing point if a language seeks for
&#8220;handy and easy&#8221;, and Ruby does.</p>
<h4>Most of syntactic elements are expressions</h4>
<p>This topic is probably difficult to understand it instantly without needs
supplemental explanation.  For example, the following C-language program
contains a syntactic error.</p>
<p>p(=emlist). 
result = if (cond) { process(val); } else { 0; }
</pre></p>
<p>Because the C-language syntax defines <code>if</code> as a statement. See following rewrite.</p>
<p>p(=emlist). 
result = cond ? process(val) : 0;
</pre></p>
<p>This rewrite is possible because the conditional operator (<code>a?b:c</code>) is defined
as an expression.</p>
<p>On the other hand, Ruby acceps a following expression because <code>if</code> is an expression.</p>
<p>p(=emlist). 
result = if cond then process(val) else nil end
</pre></p>
<p>大雑把に言うと、関数やメソッドの引数にできるものは式だと思っていい。</p>
<p>もちろん「ほとんどの文法要素が式」という言語は他にもいろいろある。例えば
Lispはその最たるものだ。このあたりの特徴からなんとなく「RubyはLispに似
てる」と感じる人が多いようである。</p>
<h4>イテレータ</h4>
<p>Rubyにはイテレータがある。イテレータとは何か。いやその前にイテレータと
いう言葉は最近嫌われているので別の言葉を使うべきかもしれない。だがい
い言葉を思いつかないので当面イテレータと呼ぶことにする。</p>
<p>それでイテレータとは何か。高階の関数を知っているなら、とりあえずはそれ
と似たようなものだと思っておけばいい。Cで言えば関数ポインタを引数
に渡すやつである。C++で言えばSTLにある@Iterator@の操作部分までをメソッド
に封入したものである。shやPerlを知っているのなら、独自に定義できる
@for@文みたいなもんだと思って見てみるといい。</p>
<p>もっともあくまでここに挙げたのは全て「似たようなもの」であって、どれも
Rubyのイテレータと似てはいるが、同じでは、全くない。いずれその時が来た
らもう少し厳密な話をしよう。</p>
<h4>C言語で書いてある</h4>
<p>Cで書いたプログラムなどいまどき珍しくもないが、特徴であることは間違い
ない。少なくともHaskellやPL/Iで書いてあるわけではないので一般人にも
読める可能性が高い（本当にそうかどうかはこれから自分で確かめてほしい）。</p>
<p>それからC言語と言っても@ruby@が対象としているのは基本的にK&amp;R Cだ。
少し前まではK&amp;R onlyの環境が、たくさんとは言わないが、それなりにあったからだ。
しかしさすがに最近はANSI Cが通らない環境はなくなってきており技術的には
<span class="caps">ANSI</span> Cに移っても特に問題はない。だが作者のまつもとさん個人の趣味もあっ
てまだK&amp;Rスタイルを通している。</p>
<p>そんなわけで関数定義は全てK&amp;Rスタイルだし、プロトタイプ宣言もあまり真面
目に書かれていない。@gcc@でうっかり@-Wall@を付けると大量に警告が出て
くるとか、
C++コンパイラでコンパイルするとプロトタイプが合わないと怒られてコンパ
イルできない&#8230;&#8230;なんて話がポロポロとメーリングリストに流れている。</p>
<h4>拡張ライブラリ</h4>
<p>RubyのライブラリをCで書くことができ、Rubyを再コンパイルすることなく
実行時にロードできる。このようなライブラリを「Ruby拡張ライブラリ」
または単に「拡張ライブラリ」と言う。</p>
<p>単にCで書けるだけでなくRubyレベルとCレベルでのコードの表現の差が小さい
のも大きな特徴である。Rubyで使える命令はほとんどそのままCでも使うこと
ができる。例えば以下のように。</p>
<p>p(=emlist).</p>
<ol>
	<li>メソッド呼び出し
obj.method(arg)                                 # Ruby
rb_funcall(obj, rb_intern(&#8220;method&#8221;), 1, arg);   # C</li>
	<li>ブロック呼び出し
yield arg        # Ruby
rb_yield(arg);   # C</li>
	<li>例外送出
raise ArgumentError, &#8216;wrong number of arguments&#8217;       # Ruby
rb_raise(rb_eArgError, &#8220;wrong number of arguments&#8221;);   # C</li>
	<li>オブジェクトの生成
arr = Array.new             # Ruby
<span class="caps">VALUE</span> arr = rb_ary_new();   # C
</pre></li>
</ol>
<p>拡張ライブラリを書くうえでは非常に楽をできていいし、現実に
このことが代えがたい@ruby@の長所にもなっている。しかしそのぶん
@ruby@の実装にとっては非常に重い足枷となっており、随所にその
影響を見ることができる。特にGCやスレッドへの影響は顕著である。</p>
<h4>スレッド</h4>
<p>Rubyにはスレッドがある。さすがに最近はスレッドを知らない人はほとんどい
ないと思うのでスレッド自体に関する説明は省略する。以下はもう少し細かい
話だ。</p>
<p>@ruby@のスレッドはオリジナルのユーザレベルスレッドである。この実装の
特徴は、仕様と実装、両方の移植性が非常に高いことである。なにしろDOS上で
さえスレッドが動き、どこでも同じ挙動で使えるのだ。この点を@ruby@の最大の
長所として挙げる人も多い。</p>
<p>しかし@ruby@スレッドは凄まじい移植性を実現した反面で速度をおもいきり犠牲
にしている。どのくらい遅いかというと、世の中に数あるユーザレベルスレッ
ドの実装の中でも一番遅いのではないか、というくらい遅い。これほど@ruby@の
実装の傾向を明確に表しているところもないだろう。</p>
<h2>ソースコードを読む技術</h2>
<p>さて。@ruby@の紹介も終わっていよいよソースコード読みに入ろうか、というと
ころだが、ちょっと待ってほしい。</p>
<p>ソースコードを読む、というのはプログラマならば誰しもやらなければいけな
いことだが、その具体的な方法を教えてもらえることはあまりないのではない
だろうか。どうしてだろう。プログラムが書けるなら読むのも当然できるとい
うのだろうか。</p>
<p>しかし筆者には人の書いたプログラムを読むことがそんなに簡単なことだとは
思えない。プログラムを書くのと同じくらい、読むことにも技術や定石がある
はずだし、必要だと考える。そこで@ruby@を読んでいく前にもう少し一般的に、
ソースコードを読むにはどういう考えかたをすればいいのか、整理することに
しよう。</p>
<h3>原則</h3>
<p>まずは原則について触れる。</p>
<h4>目的の決定
bq. 
「ソースコードを読むための極意」は『目的をもって読む』ことです。</h4>
<p>これはRuby作者のまつもとさんの言だ。なるほど、この言葉には非常にうなず
けるものがある。「カーネルくらいは読んどかなきゃいかんかなあ」と思って
ソースコードを展開したり解説本を買ったりしてはみたものの、いったいどう
していいのかわからないまま放ってしまった、という経験のある人は多いので
はないだろうか。その一方で、「このツールのどこかにバグがある、とにかく
これを速攻で直して動かさないと納期に間に合わない」&#8230;&#8230;というときには他
人のプログラムだろうとなんだろうと瞬く間に直せてしまうこともあるのでは
ないだろうか。</p>
<p>この二つのケースで違うのは、意識の持ちかたである。自分が何を知ろうと
しているのかわからなければ「わかる」ことはありえない。だからまず自分が
何を知りたいのか、それを明確に言葉にすることが全ての第一歩である。</p>
<p>だがこれだけではもちろん「技術」たりえない。「技術」とは、意識すれば誰に
でもできるものでなければならないからだ。続いて、この第一歩から最終的に
目的を達成するところまで敷衍する方法について延べる。</p>
<h4>目的の具体化</h4>
<p>いま「@ruby@全部を理解する」を最終目標に決めたとしよう。これでも「目的を
決めた」とは言えそうだが、しかし実際にソースコードを読む役に立たないこ
とは明らかである。具体的な作業には何にもつながっていないからだ。従って
まずはこの曖昧な目標を具体的なところまで引きずり下ろさなければならない。</p>
<p>どうすればいいだろうか。まず第一に、そのプログラムを書いた人間になった
つもりで考えてみることだ。そのときにはプログラムを作るときの知識が流用
できる。例えば伝統的な「構造化」プログラムを読むとしたら、こちらも
構造化プログラムの手法に則って考えるようにする。即ち目的を徐々に徐々に分割
していく。あるいはGUIプログラムのようにイベントループに入ってグルグル
するものならば、とりあえず適当にイベントループを眺めてからイベントハン
ドラの役割を調べてみる。あるいはMVC（Model View Controler）のMをまず調
べてみる。</p>
<p>第二に解析の手法を意識することだ。誰しも自分なりの解析方法というのはそ
れなりに持っていると思うが、それは経験と勘に頼って行われていることが多
い。どうしたらうまくソースコードを読めるのか、そのこと自体を考え、意識
することが非常に重要である。</p>
<p>ではそのような手法にはどんなものがあるだろうか。それを次に説明する。</p>
<h3>解析の手法</h3>
<p>ソースコードを読む手法は大雑把に言って静的な手法と動的な手法の二つに分
類できる。静的な手法とはプログラムを動かさずソースコードを読んだり解析
したりすること。動的な手法とはデバッガなどのツールを使って実際の動きを
見ることだ。</p>
<p>プログラムを調査するときはまず動的な解析から始めたほうがよい。なぜなら
それは「事実」だからだ。静的な解析では現実にプログラムを動かしていない
のでその結果は多かれ少なかれ「予想」になってしまう。真実を知りたいのな
らばまず事実から始めるべきなのだ。</p>
<p>もちろん動的な解析の結果が本当に事実であるかどうかはわからない。デバッガがバ
グっているかもしれないし、CPUが熱暴走しているかもしれない。自分が設定
した条件が間違っているかもしれない。しかし少なくとも静的解析よりは動的
な解析の結果のほうが事実に近いはずである。</p>
<h3>動的な解析
h4. 対象プログラムを使う</h3>
<p>これがなければ始まらない。そもそもそのプログラムがどういうものなのか、
どういう動作をすべきなのか、あらかじめ知っておく。</p>
<h4>デバッガで動きを追う</h4>
<p>例えば実際にコードがどこを通ってどういうデータ構造を作るか、なんていう
ことは頭の中で考えているよりも実際にプログラムを動かしてみてその結果を
見たほうが早い。それにはデバッガを使うのが簡単だ。</p>
<p>実行時のデータ構造を絵にして見られるとさらに嬉しいのだが、そういうツー
ルはなかなかない（特にフリーのものは少ない）。比較的単純な構造のスナッ
プショットくらいならテキストでさらっと書き出し
@graphviz@footnote{@graphviz@&#8230;&#8230;添付CD-ROMの@doc/graphviz.html@参照}の
ようなツールを使って絵にすることもできそうだが、汎用・リアルタイムを
目指すとかなり難しい。</p>
<h4>トレーサ</h4>
<p>コードがどの手続きを通っているか調査したければトレーサを使えばいい。
C言語なら
@ctrace@footnote{@ctrace@&#8230;&#8230;<code>http://www.vicente.org/ctrace</code>}と
いうツールがある。
またシステムコールのトレースには
@strace@footnote{@strace@&#8230;&#8230;<code>http://www.wi.leidenuniv.nl/~wichert/strace/</code>}、
@truss@、@ktrace@と言ったツールがある。</p>
<h4>printしまくる</h4>
<p>@printf@デバッグという言葉があるが、この手法はデバッグでなくても役に立つ。
特定の変数の移り変わりなどはデバッガでチマチマ辿ってみるよりもprint文を
埋め込んで結果だけまとめて見るほうがわかりやすい。</p>
<h4>書き換えて動かす</h4>
<p>例えば動作のわかりにくいところでパラメータやコードを少しだけ変えて動
かしてみる。そうすると当然動きが変わるから、コードがどういう意味なのか
類推できる。</p>
<p>言うまでもないが、オリジナルのバイナリは残しておいて
同じことを両方にやってみるべきである。</p>
<h3>静的な解析
h4. 名前の大切さ</h3>
<p>静的解析とはつまりソースコードの解析だ。そしてソースコードの解析とは名
前の調査である。ファイル名・関数名・変数名・型名・メンバ名など、プログ
ラムは名前のかたまりだ。名前はプログラムを抽象化する最大の武器なのであ
たりまえと言えばあたりまえだが、この点を意識して読むとかなり効率が違う。</p>
<p>またコーディングルールについてもあたりをつけておきたい。例えばCの関数
名なら@extern@関数にはプリフィクスを使っていることが多く、関数の種類を見
分けるのに使える。またオブジェクト指向様式のプログラムだと関数の所属情
報がプリフィクスに入っていることがあり、貴重な情報になる。
（例：@rb_str_length@）</p>
<h4>ドキュメントを読む</h4>
<p>内部構造を解説したドキュメントが入っていることもある。
特に「@HACKING@」といった名前のファイルには注意だ。</p>
<h4>ディレクトリ構造を読む</h4>
<p>どういう方針でディレクトリが分割されているのか見る。
そのプログラムがどういう作りになっているのか、
どういうパートがあるのか、概要を把握する。</p>
<h4>ファイル構成を読む</h4>
<p>ファイルの中に入っている関数（名）も合わせて見ながら、
どういう方針でファイルが分割されているのか見る。ファイル名は
有効期間が非常に長いコメントのようなものであり、注目すべきである。</p>
<p>さらに、ファイルの中にまたモジュールがある場合、モジュールを構成する関
数は近くにまとまっているはずだ。つまり関数の並び順からモジュール構成
を見付けることができる。</p>
<h4>略語の調査</h4>
<p>わかりにくい略語があればリストアップしておいて早めに調べる。
例えば「GC」と書いてあった場合、それがGarbage Collectionなのか
それともGraphic Contextなのかで随分と話が違ってしまう。</p>
<p>プログラム関係の略語はたいてい単語の頭文字を取るとか、単語から母音を落とす、
という方法で作られる。特に対象プログラムの分野で有名な略語は問答無用で
使われるのであらかじめチェックしておこう。</p>
<h4>データ構造を知る</h4>
<p>データとコードが並んでいたら、まずデータ構造から調べるべきである。つま
りCならヘッダファイルから眺めるほうが、たぶんいい。そのときはファイル
名から想像力を最大限に働かせよう。例えば言語処理系で@frame.h@というファ
イルがあったら恐らくスタックフレームの定義だ。</p>
<p>また構造体の型とメンバ名だけでも随分といろいろなことがわかる。例え
ば構造体の定義中に自分の型へのポインタで@next@というメンバがあればリンク
リストだろうと想像できる。同様に、@parent@・@children@・@sibling@と言った要
素があれば十中八九ツリーだ。@prev@ならスタックだろう。</p>
<h4>関数同士の呼び出し関係を把握する</h4>
<p>関数同士の関係は名前の次に重要な情報だ。呼び出し関係を表現したものを
特に「コールグラフ」と言うが、これは非常に便利である。このへんは
ツールを活用したい。</p>
<p>ツールはテキストベースで十分だが、図にしてくれれば文句無しだ。
ただそういう便利なものはなかなかない（特にフリーのものは少ない）。
筆者が本書のために@ruby@を解析したときは、小さなコマンド言語と
パーサを適当にRubyで書き、@graphviz@というツールに渡して半自動生成した。</p>
<h4>関数を読む</h4>
<p>動作を読んで、関数のやることを一言で説明できるようにする。関数関連図を
見ながらパートごとに読んでいくのがいい。</p>
<p>関数を読むときに重要なのは「何を読むか」ではなく「何を読まないか」であ
る。どれだけコードを削るかで読みやすさが決まると言ってよい。具体的に何
を削ればいいか、というのは実際に見せてみないとわかりづらいので本文で解
説する。</p>
<p>それとコーディングスタイルが気にいらないときは@indent@のようなツールを
使って変換してしまえばいい。</p>
<h4>好みに書き換えてみる</h4>
<p>人間の身体というのは不思議なもので、できるだけ身体のいろんな場所を使い
ながらやったことは記憶に残りやすい。パソコンのキーボードより原稿用紙の
ほうがいい、という人が少なからずいるのは、単なる懐古趣味ではなくそうい
うことも関係しているのではないかと思う。</p>
<p>そういうわけで単にモニタで読むというのは非常に身体に残りにくいので、
書き換えながら読む。そうするとわりと早く身体がコードに馴染んでくること
が多い。気にくわない名前やコードがあったら書き換える。わかりづらい略語
は置換して省略しないようにしてしまえばよい。</p>
<p>ただし当然のことだが書き換えるときはオリジナルのソースは別に残しておき、
途中で辻褄が合わないと思ったら元のソースを見て確認すること。でないと自
分の単純ミスで何時間も悩む羽目になる。それに書き換えるのはあくまで馴染
むためであって書き換えること自体が目的ではないので熱中しすぎないように
注意してほしい。</p>
<h3>歴史を読む</h3>
<p>プログラムにはたいてい変更個所の履歴を書いた文書が付いている。例えば
GNUのソフトウェアだと必ず@ChangeLog@というファイルがある。これは
「プログラムがそうなっている理由」を知るのには最高に役に立つ。</p>
<p>またCVSやSCCSのようなバージョン管理システムを使っていてしかもそれにア
クセスできる場合は、@ChangeLog@以上に利用価値が高い。CVSを例に取ると、特
定の行を最後に変更した場所を表示する@cvs annotate@、指定した版からの差分
を取る@cvs diff@などが便利だ。</p>
<p>さらに、開発用のメーリングリストやニュースグループがある場合はその過去
ログを入手してすぐに検索できるようにしておく。変更の理由がズバリ載って
いることが多いからだ。もちろんWeb上で検索できるならそれでもいい。</p>
<h3>静的解析用ツール</h3>
<p>いろいろな目的のためにいろいろなツールがあるので一口には言えないが、筆
者が一つだけ選ぶとしたら@global@をお勧めする。なんと言っても他の用途に応
用しやすい作りになっているところがポイントだ。例えば同梱されている
@gctags@は本当はタグファイルを作るためのツールなのだが、
これを使ってファイルに含まれる関数名のリストを取ることもできる。</p>
<p>p(=screen). 
~/src/ruby % gctags class.c | awk &#8216;{print $1}&#8217;
SPECIAL_SINGLETON
SPECIAL_SINGLETON
clone_method
include_class_new
ins_methods_i
ins_methods_priv_i
ins_methods_prot_i
method_list
        ：
        ：
</pre></p>
<p>とは言えこれはあくまでも筆者のお勧めなので読者は自分の好きなツールを使っ
てもらえばいい。ただその時は最低でも次の機能を備えているものを選ぶように
すべきだ。</p>
<p>ファイルに含まれる関数名をリストアップする
関数名や変数名から位置を探す（さらにそこに飛べるとなおよい）
関数クロスリファレンス</p>
<h2>ビルド
h3. 対象バージョン</h2>
<p>本書で解説している@ruby@のバージョンは1.7の2002-09-12版である。@ruby@はマ
イナーバージョンが偶数だと安定版で奇数だと開発版だから、1.7は開発版と
いうことになる。しかも9月12日は特に何かの区切りというわけではないの
で、該当バージョンの公式パッケージは配布されていない。従ってこの版を入
手するには本書添付のCD-ROMまたはサポートサイト
footnote{本書のサポートサイト&#8230;&#8230;<code>http://i.loveruby.net/ja/rhg/</code>}
から入手するか、後述のCVSを使うしかない。</p>
<p>安定版の1.6でなく1.7にした理由は、1.7のほうが仕様・実装ともに整理され
ていて扱いやすいことが一つ。次に、開発版先端のほうがCVSが使いやすい。
さらに、わりと近いうちに次の安定版の1.8が出そうな雰囲気になってきたこと。
そして最後に、最先端を見ていくほうが気分的に楽しい。</p>
<h3>ソースコードを入手する</h3>
<p>添付CD-ROMに解説対象の版のアーカイブを収録した。
CD-ROMのトップディレクトリに</p>
<p>p(=emlist). 
ruby-rhg.tar.gz
ruby-rhg.zip
ruby-rhg.lzh
</pre></p>
<p>の三種類が置いてあるので、便利なものを選んで使ってほしい。
もちろん中身はどれも同じだ。例えば@tar.gz@のアーカイブなら
次のように展開すればいいだろう。</p>
<p>p(=screen). 
~/src % mount /mnt/cdrom
~/src % gzip -dc /mnt/cdrom/ruby-rhg.tar.gz | tar xf -
~/src % umount /mnt/cdrom
</pre>
h3. コンパイルする</p>
<p>ソースコードを見るだけでも「読む」ことはできる。しかしプログラムを知る
ためには実際にそれを使い、改造し、実験してみることが必要だ。実験をする
なら見ているソースコードと同じものを使わなければ意味がないので、当然自
分でコンパイルすることになる。</p>
<p>そこでここからはコンパイルの方法を説明する。まずはUNIX系OSの場合から話
を始めよう。Windows上ではいろいろあるので次の項でまとめて話す。ただし
CygwinはWindows上ではあるがほとんどUNIXなので、こちらの話を読んでほし
い。</p>
<h4>UNIX系OSでのビルド</h4>
<p>さて、UNIX系OSなら普通Cコンパイラは標準装備なので、次の手順でやれば
たいがい通ってしまう。
<code>~/src/ruby</code>にソースコードが展開されているとする。</p>
<p>p(=screen). 
~/src/ruby % ./configure
~/src/ruby % make
~/src/ruby % su
~/src/ruby # make install
</pre></p>
<p>以下、いくつか注意すべき点を述べる。</p>
<p>Cygwin、UX/4800など一部のプラットフォームでは@configure@の段階で
<code>--enable-shared</code>オプションを付けないとリンクに失敗する。
<code>--enable-shared</code>というのは@ruby@のほとんどを共有ライブラリ
（@libruby.so@）としてコマンドの外に出すオプションである。</p>
<p>p(=screen). 
~/src/ruby % ./configure &#8212;enable-shared
</pre></p>
<p>ビルドに関するより詳しいチュートリアルを添付CD-ROMの
<code>doc/build.html</code>に入れたので、それを読みながらやってみてほしい。</p>
<h4>Windowsでのビルド</h4>
<p>Windowsでのビルドとなるとどうも話がややこしくなる。
問題の根源はビルド環境が複数あることだ。</p>
<p>Visual C++
MinGW
Cygwin
Borland C++ Compiler</p>
<p>まずCygwin環境はWindowsよりもUNIXに条件が近いのでUNIX系のビルド手順に
従えばいい。</p>
<p>Visual C++でコンパイルする場合はVisual C++ 5.0以上が
必要である。バージョン6か.NETならまず問題ないだろう。</p>
<p>MinGW、Minimalist <span class="caps">GNU</span> for WindowsというのはGNUのコンパイル環境（ようするに
@gcc@と@binutils@）をWindowsに移植したものだ。CygwinがUNIX環境全体を移植し
たのに対し、MinGWはあくまでコンパイルのためのツールだけを移植してある。
またMinGWでコンパイルしたプログラムは実行時に特別なDLLを必要としない。
つまりMinGWでコンパイルした@ruby@はVisual C++版と全く同じに扱える。</p>
<p>また個人利用ならばBorland C++ Compilerのバージョン5.5がBorlandのサイト
footnote{Borlandのサイト：@http://www.borland.co.jp@}
から無料でダウンロードできる。@ruby@がサポートしたのがかなり最近なのが
多少不安だが、本書出版前に行ったビルドテストでは特に問題は出ていない。</p>
<p>さて以上四つの環境のうちどれを選べばいいだろうか。まず基本的には
Visual C++版が最も問題が出にくいのでそれをお勧めする。UNIXの経験がある
ならCygwin一式入れてCygwinを使うのもよい。UNIXの経験がなくVisual C++も
持っていない場合はMinGWを使うのがいいだろう。</p>
<p>以下ではVisual C++とMinGWでのビルド方法について説明するが、
あくまで概要だけに留めた。より細かい解説とBorland C++ Compilerでの
ビルド方法は添付CD-ROMの@doc/build.html@に収録したので適宜そちらも
参照してほしい。</p>
<h4>Visual C++</h4>
<p>Visual C++と言っても普通はIDEは使わず、DOSプロンプトからビルドする。そ
のときはまずVisual C++自体を動かせるようにするために環境変数の初期化を
しなければいけない。Visual C++にそのためのバッチファイルが付いてくるの
で、まずはそれを実行しよう。</p>
<p>p(=screen). 
C:&gt; cd &#8220;Program FilesMicrosoft Visual Studio .NETVc7bin&#8221;
C:Program FilesMicrosoft Visual Studio .NETVc7bin&gt; vcvars32
</pre></p>
<p>これはVisual C++.NETの場合だ。バージョン6なら以下の場所にある。</p>
<p>p(=emlist). 
C:Program FilesMicrosoft Visual StudioVC98bin
</pre></p>
<p>@vcvars32@を実行したらその後は@ruby@のソースツリーの中のフォルダ
@win32@に移動してビルドすればいい。以下、ソースツリーは@C:src@に
あるとしよう。</p>
<p>p(=screen). 
C:&gt; cd srcruby
C:srcruby&gt; cd win32
C:srcrubywin32&gt; configure
C:srcrubywin32&gt; nmake
C:srcrubywin32&gt; nmake <span class="caps">DESTDIR</span>=&#8220;C:Program Filesruby&#8221; install
</pre></p>
<p>これで@C:Program Filesrubybin@に@ruby@コマンドが、
<code>C:Program Filesrubylib</code>以下にRubyのライブラリが、
それぞれインストールされる。@ruby@はレジストリなどは一切使わない
ので、アンインストールするときは@C:ruby@以下を消せばよい。</p>
<h4>MinGW</h4>
<p>前述のようにMinGWはコンパイル環境のみなので、一般的なUNIXのツール、
例えば@sed@や@sh@が存在しない。しかし@ruby@のビルドにはそれが必要なので
それをどこかから調達しなければならない。それにはまた二つの方法が
存在する。CygwinとMSYS（Minimal SYStem）である。</p>
<p>だがMSYSのほうは本書の出版前に行ったビルド大会でトラブルが続出してしまっ
たのでお勧めできない。対照的にCygwinを使う方法だと非常に素直に通った。
従って本書ではCygwinを使う方法を説明する。</p>
<p>まずCygwinの@setup.exe@でMinGWと開発ツール一式を入れておく。
CygwinとMinGWは添付CD-ROMにも収録した
footnote{CygwinとMinGW&#8230;&#8230;添付CD-ROMの@doc/win.html@を参照}。
あとはCygwinの@bash@プロンプトから以下のように打てばよい。</p>
<p>p(=screen). 
~/src/ruby % ./configure &#8212;with-gcc=&#8216;gcc -mno-cygwin&#8217; 
                                 &#8212;enable-shared i386-mingw32
~/src/ruby % make
~/src/ruby % make install
</pre></p>
<p>これだけだ。ここでは@configure@の行を折り返しているが実際には一行に
入れる。またバックスラッシュを入れる必要はない。インストール先は
コンパイルしたドライブの@usrlocal@以下になる。このあたりはかなり
ややこしいことが起こっていて説明が長くなるので、
添付CD-ROMの@doc/build.html@で徹底的に説明しよう。</p>
<h2>ビルド詳細</h2>
<p>ここまでが@README@的な解説である。今度はこれまでやったことが具体的に
何をしているのか、つっこんで見ていこう。ただしここの話は部分的に
かなり高度な知識が必要になる。わからない場合はいきなり次の節に
飛んでほしい。本書全体を読んでから戻ってきてもらえばわかるように
なっているはずだ。</p>
<p>さて、どのプラットフォームでも@ruby@のビルドは三段階に分かれている。
即ち@configure@、@make@、@make install@だ。@make install@はいいとして、
@configure@と@make@の段階について解説しよう。</p>
<h3><code>configure</code></h3>
<p>まず@configure@である。この中身はシェルスクリプトになっており、これ
でシステムのパラメータを検出する。例えば「ヘッダファイル@setjmp.h@が存
在するか」とか、「@alloca()@は使えるか」ということを調べてくれる。調べ
る方法は意外と単純である。</p>
<p>チェック対象方法
コマンド実際に実行してみて@$?<code>を見る
ヘッダファイル</code>if [ -f $includedir/stdio.h ]@
関数小さいプログラムをコンパイルしてみてリンクが成功するかどうか試す</p>
<p>違いを検出したら、それをどうにかしてこちらに伝えてもらわないと
いけない。その方法は、まず@Makefile@が一つ。パラメータを@@PARAM@@の
ように埋め込んだ@Makefile.in@を置いておくと、それを実際の値に変換
した@Makefile@を生成してくれる。例えば次のように。</p>
<p>p(=emlist). 
Makefile.in:  <span class="caps">CFLAGS</span> = <code>CFLAGS</code>
                     ↓
Makefile   :  <span class="caps">CFLAGS</span> = -g -O2
</pre></p>
<p>もう一つ、関数やヘッダファイルがあるかどうかといった情報を
ヘッダファイルにして出力してくれる。出力ファイルの名前は変更
できるのでプログラムによって違うが、@ruby@では@config.h@である。
@configure@を実行した後にこのファイルができていることを確かめてほしい。
中身はこんな感じだ。</p>
<p>p(=caption). ▼@config.h@
p(=longlist). 
         ：
         ：
#define HAVE_SYS_STAT_H 1
#define HAVE_STDLIB_H 1
#define HAVE_STRING_H 1
#define HAVE_MEMORY_H 1
#define HAVE_STRINGS_H 1
#define HAVE_INTTYPES_H 1
#define HAVE_STDINT_H 1
#define HAVE_UNISTD_H 1
#define <em>FILE_OFFSET_BITS 64
#define HAVE_LONG_LONG 1
#define HAVE_OFF_T 1
#define SIZEOF_INT 4
#define <span class="caps">SIZEOF</span></em><span class="caps">SHORT</span> 2
         ：
         ：
</pre></p>
<p>どれも意味はわかりやすい。@HAVE_xxxx_H@ならヘッダファイルが存在するか
どうかのチェックだろうし、@SIZEOF_SHORT@ならCの@short@型が何バイトかを
示しているに違いない。同じく@SIZEOF_INT@なら@int@のバイト長だし、
@HAVE_OFF_T@は@offset_t@型が定義されているかを示している。これに限らず
@configure@では「ある／ない」の情報は@HAVE_xxxx@というマクロで定義される
（する）。</p>
<p>以上のことからわかるように、@configure@は違いを検出してはくれるが、
その違いを自動的に吸収してくれるわけではない。ここで定義された値を
使って差を埋めるのはあくまで各プログラマの仕事である。例えば次の
ように。</p>
<p>p(=caption). ▼@HAVE_@マクロの典型的な使いかた
p(=longlist). 
  24  #ifdef HAVE_STDLIB_H
  25  # include 
  26  #endif
(ruby.h)
</pre>
h3. <code>autoconf</code></p>
<p>@configure@は@ruby@の専用ツールではない。関数があるか、ヘッダファイルが
あるか&#8230;&#8230;といったテストには明らかに規則性があるのだから、プログラムを
書く人がみんなでそれぞれに別のものを書くのは無駄だ。</p>
<p>そこで登場するのが@autoconf@というツールである。@configure.in@とか
<code>configure.ac</code>というファイルに「こういうチェックがしたいんだ」と
書いておき、それを@autoconf@で処理すると適切な@configure@を作ってくれる。
<code>configure.in</code>の@.in@は@input@の略だろう。@Makefile@と@Makefile.in@の関係と
同じである。@.ac@のほうはもちろん@AutoConf@の略だ。</p>
<p>ここまでを絵にすると図1のようになる。</p>
<p>p(=image). 
<p class="image">
<img src="images/ch_abstract_build.jpg" alt="(build)"><br>
Figure 1: [build]</p>
</p>
<p>図1: @Makefile@ができるまで</p>
<p>もっと詳しいことが知りたい読者には『GNU Autoconf/Automake/Libtool』
footnote{『GNU Autoconf/Automake/Libtool』Gary V.Vaughan, Ben Elliston, Tom Tromey, Ian Lance Taylor共著、でびあんぐる監訳、オーム社}
をお勧めする。</p>
<p>ところで@ruby@の@configure@は言ったとおり@autoconf@を使って生成してい
るのだが、世の中にある@configure@が必ずしも@autoconf@で生成されている
とは限らない。手書きだったり、別の自動生成ツールを使っていたりすること
もある。なんにせよ、最終的に@Makefile@や@config.h@やその他いろいろがで
きればそれでいいのだ。</p>
<h3><code>make</code></h3>
<p>第二段階、@make@では何をするのだろうか。もちろん@ruby@のソースコードを
コンパイルするわけだが、@make@の出力を見ているとどうもその他にいろいろ
やっているように見える。その過程を簡単に説明しておこう。</p>
<p>@ruby@自体を構成するソースコードをコンパイルする。
@ruby@の主要部分を集めたスタティックライブラリ@libruby.a@を作る。
常にスタティックリンクされる@ruby@「@miniruby@」を作る。
<code>--enable-shared</code>のときは共有ライブラリ@libruby.so@を作る。
@miniruby@を使って拡張ライブラリ（@ext/<code>以下）をコンパイルする。
最後に、本物の</code>ruby@を生成する。</p>
<p>@miniruby@と@ruby@の生成が分かれているのには二つ理由がある。一つめは拡張ラ
イブラリのコンパイルに@ruby@が必要になることだ。@&#8212;enable-shared@の場合は
@ruby@自身がダイナミックリンクされるので、ライブラリのロードパスの関係で
すぐに動かせないかもしれない。そこでスタティックリンクした@miniruby@を作り、
ビルドの過程ではそちらを使うようにする。</p>
<p>二つめの理由は、共有ライブラリが使えないプラットフォームでは拡張ライブ
ラリを@ruby@自体にスタティックリンクしてしまう場合があるということだ。そ
の場合、@ruby@は拡張ライブラリを全てコンパイルしてからでないと作れないが、
拡張ライブラリは@ruby@がないとコンパイルできない。そのジレンマを解消する
ために@miniruby@を使うのである。</p>
<h2><span class="caps">CVS</span></h2>
<p>本書の添付CD-ROMに入っている@ruby@のアーカイブにしても公式のリリースパッ
ケージにしても、それは@ruby@という、変化しつづているプログラムのほんの一
瞬の姿をとらえたスナップショットにすぎない。@ruby@がどう変わってきたか、
どうしてそうだったのか、ということはここには記述されていない。では過去
も含めた全体を見るにはどうしたらいいだろうか。CVSを使えばそれができる。</p>
<h3>CVSとは</h3>
<p>CVSを一言で言うとエディタのundoリストである。
ソースコードをCVSの管理下に入れておけばいつでも昔の姿に戻せるし、誰が、
どこを、いつ、どう変えたのかすぐにわかる。一般にそういうことをしてくれ
るプログラムのことをソースコード管理システムと言うが、オープンソースの
世界で一番有名なソースコード管理システムがCVSである。</p>
<p>@ruby@もやはりCVSで管理されているのでCVSの仕組みと使いかたについて少し説
明しよう。まずCVSの最重要概念はレポジトリとワーキングコピーである。
CVSはエディタのundoリストのようなものと言ったが、そのためには歴代の変更の
記録を
どこかに残しておかないといけない。それを全部まとめて保存しておく場所が
「CVSレポジトリ」である。</p>
<p>ぶっちゃけて言うと、過去のソースコードを全部集めてあるのがレポジトリで
ある。もちろんそれはあくまで概念であって、実際には容量を節約するために、
最新の姿一つと、そこに至るまでの変更差分（ようするにパッチ）の形で集積
されている。なんにしてもファイルの過去の姿をどの時点だろうと取り出せる
ようになっていればそれでいいのだ。</p>
<p>一方、レポジトリからある一点を選んでファイルを取り出したものが
「ワーキングコピー」だ。レポジトリは一つだけだがワーキングコピーは
いくつあってもいい（図2）。</p>
<p>p(=image). 
<p class="image">
<img src="images/ch_abstract_repo.jpg" alt="(repo)"><br>
Figure 2: [repo]</p>
</p>
<p>図2: レポジトリとワーキングコピー</p>
<p>自分がソースコードを変更したいときはまずワーキングコピーを取り出して、
それをエディタなどで編集してからレポジトリに「戻す」。するとレポジトリ
に変更が記録される。レポジトリからワーキングコピーを取り出すことを
「チェックアウト（checkout）」、戻すことを「チェックイン
（checkin）」
または「コミット（commit）」と言う（図3）。チェックインするとレ
ポジトリに変更が記録されて、いつでもそれを取り出せるようになる。</p>
<p>p(=image). 
<p class="image">
<img src="images/ch_abstract_ci.jpg" alt="(ci)"><br>
Figure 3: [ci]</p>
</p>
<p>図3: チェックインとチェックアウト</p>
<p>そしてCVS最大の特徴はCVSレポジトリにネットワーク越しにアクセスできると
いうところだ。つまりレポジトリを保持するサーバが一つあればインターネッ
ト越しに誰でもどこからでもチェックアウト・チェックインすることができる。
ただし普通はチェックインにはアクセス制限がかかっているので無制限
にできるというわけではない。</p>
<h4>リビジョン</h4>
<p>レポジトリから特定の版を取り出すにはどうしたらいいだろうか。一つには時
刻で指定する方法がある。「この当時の最新版をくれ」と要求するとそれを選
んでくれるわけだ。しかし実際には時刻で指定することはあまりない。普通は
「リビジョン（revision）」というものを使う。</p>
<p>「リビジョン」は「バージョン」とほとんど同じ意味である。ただ普通はプロ
ジェクト自体に「バージョン」が付いているので、バージョンという言葉を使
うと紛らわしい。そこでもうちょっと細かい単位を意図してリビジョンという
言葉を使う。</p>
<p>CVSでは、レポジトリに入れたばかりのファイルはリビジョン1.1である。
チェックアウトして、変更して、チェックインするとリビジョン1.2になる。
その次は1.3になる。その次は1.4になる。</p>
<h4>CVSの簡単な使用例</h4>
<p>以上をふまえてごくごく簡単にCVSの使いかたを話す。まず@cvs@コマンドがな
いとどうにもならないのでインストールしておいてほしい。添付CD-ROMにも
@cvs@のソースコードを収録した
footnote{@cvs@：@archives/cvs-1.11.2.tar.gz@}。
@cvs@のインストールの方法はあまりにも本筋から外れるのでここでは書かな
い。</p>
<p>インストールしたら試しに@ruby@のソースコードをチェックアウトしてみよう。
インターネットに接続中に次のように打つ。</p>
<p>p(=screen). 
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src login
<span class="caps">CVS</span> Password: anonymous
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout ruby
</pre></p>
<p>何もオプションを付けないと自動的に最新版がチェックアウトされるので、
<code>ruby/</code>以下に@ruby@の真の最新版が現れているはずだ。</p>
<p>また、とある日の版を取り出すには@cvs checkout@に@-D@オプションをつけれ
ばいい。次のように打てば本書が解説しているバージョンのワーキングコピー
が取り出せる。</p>
<p>p(=screen). 
% cvs -d :pserver:anonymous@cvs.ruby-lang.org:/src checkout -D2002-09-12 ruby
</pre></p>
<p>このとき、オプションは必ず@checkout@の直後に書かないといけないことに注
意。先に「@ruby@」を書いてしまうと「モジュールがない」という変なエラー
になる。</p>
<p>ちなみにこの例のようなanonymousアクセスだとチェックインはできないようになっている。
チェックインの練習をするには適当に（ローカルの）レポジトリを作って
Hello, World!プログラムでも入れてみるのがいいだろう。具体的な入れかた
はここには書かない。@cvs@に付いてくるマニュアルが結構親切だ。日本語の書
籍ならオーム社の『CVSによるオープンソース開発』
footnote{『CVSによるオープンソース開発』Karl Fogel, Moshe Bar共著、竹内利佳訳、オーム社}
をお勧めする。</p>
<h2>@ruby@の構成
h3. 物理構造</h2>
<p>さてそろそろソースコードを見ていこうと思うのだが、まず最初にしなければ
ならないことはなんだろうか。それはディレクトリ構造を眺めることである。
たいていの場合ディレクトリ構造すなわちソースツリーはそのままプログラム
のモジュール構造を示している。いきなり@grep@で@main()<code>を探して頭から処理順
に読んでいく、なんていうのは賢くない。もちろん</code>main()<code>を探すのも大切だが、
まずはのんびりと</code>ls@したり@head@したりして全体の様子をつかもう。</p>
<p>以下はCVSレポジトリからチェックアウトした直後の
トップディレクトリの様子だ。
スラッシュで終わっているのはサブディレクトリである。</p>
<p>p(=emlist). 
<span class="caps">COPYING</span>        compar.c       gc.c           numeric.c      sample/
<span class="caps">COPYING</span>.ja     config.guess   hash.c         object.c       signal.c
<span class="caps">CVS</span>/           config.sub     inits.c        pack.c         sprintf.c
ChangeLog      configure.in   install-sh     parse.y        st.c
<span class="caps">GPL</span>            cygwin/        instruby.rb    prec.c         st.h
<span class="caps">LEGAL</span>          defines.h      intern.h       process.c      string.c
<span class="caps">LGPL</span>           dir.c          io.c           random.c       struct.c
<span class="caps">MANIFEST</span>       djgpp/         keywords       range.c        time.c
Makefile.in    dln.c          lex.c          re.c           util.c
<span class="caps">README</span>         dln.h          lib/           re.h           util.h
<span class="caps">README</span>.<span class="caps">EXT</span>     dmyext.c       main.c         regex.c        variable.c
<span class="caps">README</span>.<span class="caps">EXT</span>.ja  doc/           marshal.c      regex.h        version.c
<span class="caps">README</span>.ja      enum.c         math.c         ruby.1         version.h
ToDo           env.h          misc/          ruby.c         vms/
array.c        error.c        missing/       ruby.h         win32/
bcc32/         eval.c         missing.h      rubyio.h       x68/
bignum.c       ext/           mkconfig.rb    rubysig.h
class.c        file.c         node.h         rubytest.rb
</pre></p>
<p>最近はプログラム自体が大きくなってきてサブディレクトリが細かく分割され
ているソフトウェアも多いが、@ruby@はかなり長いことトップディレクトリ
一筋である。あまりにファイル数が多いと困るが、この程度なら慣れればな
んでもない。</p>
<p>トップレベルのファイルは六つに分類できる。即ち</p>
<p>ドキュメント
@ruby@自身のソースコード
@ruby@ビルド用のツール
標準添付拡張ライブラリ
標準添付Rubyライブラリ
その他</p>
<p>である。ソースコードとビルドツールが重要なのは当然として、その他に
我々の役に立ちそうなものを挙げておこう。</p>
<p><code>ChangeLog</code></p>
<p>@ruby@への変更の記録。変更の理由を調べるうえでは非常に重要。</p>
<p><code>README.EXT README.EXT.ja</code></p>
<p>拡張ライブラリの作成方法が書いてあるのだが、その一環として
@ruby@自身の実装に関することも書いてある。</p>
<h3>ソースコードの腑分け</h3>
<p>ここからは@ruby@自身のソースコードについてさらに細かく分割していく。
主要なファイルについては@README.EXT@に分類が書いてあったので
それに従う。記載がないものは筆者が分類した。</p>
<h4>Ruby言語のコア</h4>
<p><code>class.c</code>クラス関連API
<code>error.c</code>例外関連API
<code>eval.c</code>評価器
<code>gc.c</code>ガーベージコレクタ
<code>lex.c</code>予約語テーブル
<code>object.c</code>オブジェクトシステム
<code>parse.y</code>パーサ
<code>variable.c</code>定数、グローバル変数、クラス変数
<code>ruby.h</code>@ruby@の主要マクロとプロトタイプ
<code>intern.h</code>@ruby@のC APIのプロトタイプ。@intern@はinternalの略だと思われるが、ここに載っている関数を拡張ライブラリで使うのは別に構わない。
<code>rubysig.h</code>シグナル関係のマクロを収めたヘッダファイル
<code>node.h</code>構文木ノード関連の定義
<code>env.h</code>評価器のコンテキストを表現する構造体の定義</p>
<p>@ruby@インタプリタのコアを構成する部分。本書が解説するのは
ここのファイルがほとんどである。@ruby@全体のファイル数と比べれば
非常に少ないが、バイトベースでは全体の50%近くを占める。
特に@eval.c@は200Kバイト、@parse.y@が100Kバイトと大きい。</p>
<h4>ユーティリティ</h4>
<p><code>dln.c</code>動的ローダ
<code>regex.c</code>正規表現エンジン
<code>st.c</code>ハッシュテーブル
<code>util.c</code>基数変換やソートなどのライブラリ</p>
<p>@ruby@にとってのユーティリティという意味。ただしユーティリティという
言葉からは想像できないほど大きいものもある。例えば@regex.c@は120Kバイトだ。</p>
<h4>@ruby@コマンドの実装</h4>
<p><code>dmyext.c</code>拡張ライブラリ初期化ルーチンのダミー（DumMY EXTention）
<code>inits.c</code>コアとライブラリの初期化ルーチンのエントリポイント
<code>main.c</code>コマンドのエントリポイント（@libruby@には不要）
<code>ruby.c</code>@ruby@コマンドの主要部分（@libruby@にも必要）
<code>version.c</code>@ruby@のバージョン</p>
<p>コマンドラインで@ruby@と打って実行するときの@ruby@コマンドの実装。コマンドライン
オプションの解釈などを行っている部分だ。@ruby@コマンド以外に@ruby@コアを利
用するコマンドとしては@mod_ruby@や@vim@が挙げられる。これらのコマンドは
ライブラリ@libruby@（@.a@/<code>.so</code>/<code>.dll</code>など）とリンクして動作する。</p>
<h4>クラスライブラリ</h4>
<p><code>array.c</code><code>class Array</code>
<code>bignum.c</code><code>class Bignum</code>
<code>compar.c</code><code>module Comparable</code>
<code>dir.c</code><code>class Dir</code>
<code>enum.c</code><code>module Enumerable</code>
<code>file.c</code><code>class File</code>
<code>hash.c</code><code>class Hash</code>（実体は@st.c@）
<code>io.c</code><code>class IO</code>
<code>marshal.c</code><code>module Marshal</code>
<code>math.c</code><code>module Math</code>
<code>numeric.c</code><code>class Numeric</code>、@Integer@、@Fixnum@、@Float@
<code>pack.c</code><code>Array#pack</code>、@String#unpack@
<code>prec.c</code><code>module Precision</code>
<code>process.c</code><code>module Process</code>
<code>random.c</code><code>Kernel#srand()</code>、@rand()@
<code>range.c</code><code>class Range</code>
<code>re.c</code><code>class Regexp</code>（実体は@regex.c@）
<code>signal.c</code><code>module Signal</code>
<code>sprintf.c</code>@ruby@専用の@sprintf()@
<code>string.c</code><code>class String</code>
<code>struct.c</code><code>class Struct</code>
<code>time.c</code><code>class Time</code></p>
<p>Rubyのクラスライブラリの実装。ここにあるものは基本的に通常の
Ruby拡張ライブラリと全く同じ方法で実装されている。つまりこの
ライブラリが拡張ライブラリの書きかたの例にもなっているということだ。</p>
<h4>プラットフォーム依存ファイル</h4>
<p><code>bcc32/</code>Borland C++（Win32）
<code>beos/</code>BeOS
<code>cygwin/</code>Cygwin（Win32でのUNIXエミュレーションレイヤー）
<code>djgpp/</code>djgpp（DOS用のフリーな開発環境）
<code>vms/</code>VMS（かつてDECがリリースしていたOS）
<code>win32/</code>Visual C++（Win32）
<code>x68/</code>Sharp X680x0系（OSはHuman68k）</p>
<p>各プラットフォーム特有のコードが入っている。</p>
<h4>フォールバック関数
p(=emlist). 
missing/
</pre></h4>
<p>各種プラットフォームにない関数を補うためのファイル。
主に@libc@の関数が多い。</p>
<h3>論理構造</h3>
<p>さて、以上四つのグループのうちコアはさらに大きく三つに分けられる。
一つめはRubyのオブジェクト世界を作りだす「オブジェクト空間（object space）」。
二つめはRubyプログラム（テキスト）を内部形式に変換する「パーサ（parser）」。
三つめはRubyプログラムを駆動する「評価器（evaluator）」。
パーサも評価器もオブジェクト空間の上に成立し、
パーサがプログラムを内部形式に変換し、
評価器がプログラムを駆動する。
順番に解説していこう。</p>
<h4>オブジェクト空間</h4>
<p>一つめのオブジェクト空間。これは非常に、理解しやすい。なぜならこれが扱
うものは基本的にメモリ上のモノが全てであり、関数を使って直接表示したり
操作したりすることができるからだ。従って本書ではまずここから解説を
始める。第2章から
第7章までが第一部である。</p>
<h4>パーサ</h4>
<p>二つめのパーサ。これは説明が必要だろう。</p>
<p>@ruby@コマンドはRuby言語のインタプリタである。つまり起動時にテキストの入
力を解析し、それに従って実行する。だから@ruby@はテキストとして書かれたプ
ログラムの意味を解釈できなければいけないのだが、不幸にしてテキストとい
うのはコンピュータにとっては非常に理解しづらいものである。コンピュータ
にとってはテキストファイルはあくまでバイト列であって、それ以上ではない。
そこからテキストの意味を読みとるには何か特別な仕掛けが必要になる。そ
の仕掛けがパーサだ。このパーサを通すことでRubyプログラム（であるテキス
ト）は@ruby@専用の、プログラムから扱いやすい内部表現に変換される。</p>
<p>その内部表現とは具体的には「構文木」というものだ。構文木はプログラムを
ツリー構造で表現したもので、例えば@if@文ならば図4のように
表現される。</p>
<p>p(=image). 
<p class="image">
<img src="images/ch_abstract_syntree.jpg" alt="(syntree)"><br>
Figure 4: [syntree]</p>
</p>
<p>図4: @if@文と、それに対応する構文木</p>
<p>パーサの解説は第二部『構文解析』で行う。
第二部は第10章から第12章までだ。
対象となるファイルは@parse.y@だけである。</p>
<h4>評価器</h4>
<p>オブジェクトは実際に触ることができるのでわかりやすい。パーサにしてもやっ
ていること自体はようするにデータ形式の変換なんだから、まあわかる。しか
し三つめの評価器、こいつはつかみどころが全くない。</p>
<p>評価器がやるのは構文木に従ってプログラムを「実行」していくことだ。と言
うと簡単そうに見えるのだが、では「実行する」とはどういうことか、ちゃん
と考えるとこれが結構難しい。@if@文を実行するとはどういうことだろうか。
@while@文を実行するとはどういうことだろうか。ローカル変数に代入するとは
どういうことだろうか。メソッドを呼ぶとはどういうことだろうか。その
全てにキチンキチンと答えを出していかなければ評価器はわからないのだ。</p>
<p>本書では第三部『評価』で評価器を扱う。対象ファイルは@eval.c@だ。
「評価器」は英語でevaluatorと言うので、それを省略して@eval@である。</p>
<p>さて、@ruby@の作りについて簡単に説明してきたが、プログラムの動作なんてい
くら概念を説明してもわかりにくいものだ。次の章ではまず実際に@ruby@を使う
ことから始めるとしよう。</p>
<p>御意見・御感想・誤殖の指摘などは
&#8220;青木峰郎 &quot;:mailto:aamine@loveruby.net
までお願いします。</p>
<p><a href="http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&amp;spm_id=1&amp;GM_ID=1721">『Rubyソースコード完全解説』
</a><a href="http://direct.ips.co.jp/directsys/go_x_TempChoice.cfm?sh_id=EE0040&amp;spm_id=1&amp;GM_ID=1721">はインプレスダイレクトで御予約・御購入いただけます (書籍紹介ページへ飛びます)。</a></p>
<p>Copyright &#169; 2002-2004 Minero Aoki, All rights reserved.</p>

    <footer>
      The original work is Copyright © 2002 - 2004 Minero AOKI.
      Translated by Vincent ISAMBART and Clifford Escobar CAOILE
      This work is licensed under a
      <p>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/2.5/">Creative Commons Attribution-NonCommercial-ShareAlike2.5 License</a>
      </p>
    </footer>

  </div>
</body>
</html>
